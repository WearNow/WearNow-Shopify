{
  "version": 3,
  "sources": ["../../@apollo/src/link/utils/fromError.ts", "../../@apollo/src/link/utils/toPromise.ts", "../../@apollo/src/link/utils/fromPromise.ts", "../../@apollo/src/link/utils/throwServerError.ts", "../../@apollo/src/link/utils/validateOperation.ts", "../../@apollo/src/link/utils/createOperation.ts", "../../@apollo/src/link/utils/transformOperation.ts", "../../@apollo/src/link/utils/filterOperationVariables.ts", "../../@apollo/src/link/core/ApolloLink.ts", "../../@apollo/src/link/core/empty.ts", "../../@apollo/src/link/core/from.ts", "../../@apollo/src/link/core/split.ts", "../../@apollo/src/link/core/concat.ts", "../../@apollo/src/link/core/execute.ts", "../../@apollo/src/link/http/iterators/async.ts", "../../@apollo/src/link/http/iterators/nodeStream.ts", "../../@apollo/src/link/http/iterators/promise.ts", "../../@apollo/src/link/http/iterators/reader.ts", "../../@apollo/src/link/http/responseIterator.ts", "../../@apollo/src/errors/index.ts", "../../@apollo/src/link/http/parseAndCheckHttpResponse.ts", "../../@apollo/src/link/http/serializeFetchParameter.ts", "../../@apollo/src/link/http/selectHttpOptionsAndBody.ts", "../../@apollo/src/link/http/checkFetcher.ts", "../../@apollo/src/link/http/createSignalIfSupported.ts", "../../@apollo/src/link/http/selectURI.ts", "../../@apollo/src/link/http/rewriteURIForGET.ts", "../../@apollo/src/link/http/createHttpLink.ts", "../../@apollo/src/link/http/HttpLink.ts", "../../@apollo/src/core/networkStatus.ts", "../../@apollo/src/core/ObservableQuery.ts", "../../@apollo/src/core/LocalState.ts", "../../@apollo/src/core/QueryInfo.ts", "../../@apollo/src/core/QueryManager.ts", "../../@apollo/src/core/ApolloClient.ts", "../../@apollo/src/core/index.ts"],
  "sourcesContent": ["import { Observable } from \"../../utilities/index.js\";\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>((observer) => {\n    observer.error(errorValue);\n  });\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport type { Observable } from \"../../utilities/index.js\";\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: (data) => {\n        if (completed) {\n          invariant.warn(\n            `Promise Wrapper does not support multiple results from Observable`\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n", "import { Observable } from \"../../utilities/index.js\";\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>((observer) => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n", "export type ServerError = Error & {\n  response: Response;\n  result: Record<string, any> | string;\n  statusCode: number;\n};\n\nexport const throwServerError = (\n  response: Response,\n  result: any,\n  message: string\n) => {\n  const error = new Error(message) as ServerError;\n  error.name = \"ServerError\";\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n  throw error;\n};\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { GraphQLRequest } from \"../core/index.js\";\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    \"query\",\n    \"operationName\",\n    \"variables\",\n    \"extensions\",\n    \"context\",\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw newInvariantError(`illegal argument: %s`, key);\n    }\n  }\n\n  return operation;\n}\n", "import type { GraphQLRequest, Operation } from \"../core/index.js\";\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest\n): Operation {\n  let context = { ...starting };\n  const setContext: Operation[\"setContext\"] = (next) => {\n    if (typeof next === \"function\") {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext: Operation[\"getContext\"] = () => ({ ...context });\n\n  Object.defineProperty(operation, \"setContext\", {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, \"getContext\", {\n    enumerable: false,\n    value: getContext,\n  });\n\n  return operation as Operation;\n}\n", "import type { GraphQLRequest, Operation } from \"../core/index.js\";\nimport { getOperationName } from \"../../utilities/index.js\";\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // Best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== \"string\" ?\n        getOperationName(transformedOperation.query) || undefined\n      : \"\";\n  }\n\n  return transformedOperation as Operation;\n}\n", "import type { VariableDefinitionNode, DocumentNode } from \"graphql\";\nimport { visit } from \"graphql\";\n\nexport function filterOperationVariables(\n  variables: Record<string, any>,\n  query: DocumentNode\n) {\n  const result = { ...variables };\n  const unusedNames = new Set(Object.keys(variables));\n  visit(query, {\n    Variable(node, _key, parent) {\n      // A variable type definition at the top level of a query is not\n      // enough to silence server-side errors about the variable being\n      // unused, so variable definitions do not count as usage.\n      // https://spec.graphql.org/draft/#sec-All-Variables-Used\n      if (\n        parent &&\n        (parent as VariableDefinitionNode).kind !== \"VariableDefinition\"\n      ) {\n        unusedNames.delete(node.name.value);\n      }\n    },\n  });\n  unusedNames.forEach((name) => {\n    delete result![name];\n  });\n  return result;\n}\n", "import { newInvariantError, invariant } from \"../../utilities/globals/index.js\";\n\nimport type { Observer } from \"../../utilities/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type {\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n  GraphQLRequest,\n} from \"./types.js\";\nimport {\n  validateOperation,\n  createOperation,\n  transformOperation,\n} from \"../utils/index.js\";\n\nfunction passthrough(op: Operation, forward: NextLink) {\n  return (forward ? forward(op) : Observable.of()) as Observable<FetchResult>;\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === \"function\" ? new ApolloLink(handler) : handler;\n}\n\nfunction isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport class ApolloLink {\n  public static empty(): ApolloLink {\n    return new ApolloLink(() => Observable.of());\n  }\n\n  public static from(links: (ApolloLink | RequestHandler)[]): ApolloLink {\n    if (links.length === 0) return ApolloLink.empty();\n    return links.map(toLink).reduce((x, y) => x.concat(y)) as ApolloLink;\n  }\n\n  public static split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    const leftLink = toLink(left);\n    const rightLink = toLink(right || new ApolloLink(passthrough));\n\n    let ret: ApolloLink;\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n      ret = new ApolloLink((operation) => {\n        return test(operation) ?\n            leftLink.request(operation) || Observable.of()\n          : rightLink.request(operation) || Observable.of();\n      });\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return test(operation) ?\n            leftLink.request(operation, forward) || Observable.of()\n          : rightLink.request(operation, forward) || Observable.of();\n      });\n    }\n    return Object.assign(ret, { left: leftLink, right: rightLink });\n  }\n\n  public static execute(\n    link: ApolloLink,\n    operation: GraphQLRequest\n  ): Observable<FetchResult> {\n    return (\n      link.request(\n        createOperation(\n          operation.context,\n          transformOperation(validateOperation(operation))\n        )\n      ) || Observable.of()\n    );\n  }\n\n  public static concat(\n    first: ApolloLink | RequestHandler,\n    second: ApolloLink | RequestHandler\n  ) {\n    const firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n      invariant.warn(\n        `You are calling concat on a terminating link, which will have no effect %o`,\n        firstLink\n      );\n      return firstLink;\n    }\n    const nextLink = toLink(second);\n\n    let ret: ApolloLink;\n    if (isTerminating(nextLink)) {\n      ret = new ApolloLink(\n        (operation) =>\n          firstLink.request(\n            operation,\n            (op) => nextLink.request(op) || Observable.of()\n          ) || Observable.of()\n      );\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return (\n          firstLink.request(operation, (op) => {\n            return nextLink.request(op, forward) || Observable.of();\n          }) || Observable.of()\n        );\n      });\n    }\n    return Object.assign(ret, { left: firstLink, right: nextLink });\n  }\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    return this.concat(\n      ApolloLink.split(test, left, right || new ApolloLink(passthrough))\n    );\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return ApolloLink.concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink\n  ): Observable<FetchResult> | null {\n    throw newInvariantError(\"request is not implemented\");\n  }\n\n  protected onError(\n    error: any,\n    observer?: Observer<FetchResult>\n  ): false | void {\n    if (observer && observer.error) {\n      observer.error(error);\n      // Returning false indicates that observer.error does not need to be\n      // called again, since it was already called (on the previous line).\n      // Calling observer.error again would not cause any real problems,\n      // since only the first call matters, but custom onError functions\n      // might have other reasons for wanting to prevent the default\n      // behavior by returning false.\n      return false;\n    }\n    // Throw errors will be passed to observer.error.\n    throw error;\n  }\n\n  public setOnError(fn: ApolloLink[\"onError\"]): this {\n    this.onError = fn;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly left?: ApolloLink;\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly right?: ApolloLink;\n\n  /**\n   * @internal\n   * Can be provided by a link that has an internal cache to report it's memory details.\n   */\n  getMemoryInternals?: () => unknown;\n}\n", "import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const empty = ApolloLink.empty;\n", "import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const from = ApolloLink.from;\n", "import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const split = ApolloLink.split;\n", "import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const concat = ApolloLink.concat;\n", "import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const execute = ApolloLink.execute;\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\n\nexport default function asyncIterator<T>(\n  source: AsyncIterableIterator<T>\n): AsyncIterableIterator<T> {\n  const iterator = source[Symbol.asyncIterator]();\n  return {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n      return this;\n    },\n  };\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void,\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length)\n        return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface PromiseIterator<T> {\n  next(): Promise<IteratorResult<T, ArrayBuffer | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function promiseIterator<T = ArrayBuffer>(\n  promise: Promise<ArrayBuffer>\n): AsyncIterableIterator<T> {\n  let resolved = false;\n\n  const iterator: PromiseIterator<T> = {\n    next(): Promise<IteratorResult<T, ArrayBuffer | undefined>> {\n      if (resolved)\n        return Promise.resolve({\n          value: undefined,\n          done: true,\n        });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value: value as unknown as T, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface ReaderIterator<T> {\n  next(): Promise<IteratorResult<T, T | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function readerIterator<T>(\n  reader: ReadableStreamDefaultReader<T>\n): AsyncIterableIterator<T> {\n  const iterator: ReaderIterator<T> = {\n    next() {\n      return reader.read() as Promise<\n        | ReadableStreamReadValueResult<T>\n        // DoneResult has `value` optional, which doesn't comply with an\n        // `IteratorResult`, so we assert it to `T | undefined` instead\n        | Required<ReadableStreamReadDoneResult<T | undefined>>\n      >;\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<\n      T,\n      T | undefined\n    > {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\n\nimport type { Response as NodeResponse } from \"node-fetch\";\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\n\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\n\nfunction isNodeResponse(value: any): value is NodeResponse {\n  return !!(value as NodeResponse).body;\n}\n\nfunction isReadableStream(value: any): value is ReadableStream<any> {\n  return !!(value as ReadableStream<any>).getReader;\n}\n\nfunction isAsyncIterableIterator(\n  value: any\n): value is AsyncIterableIterator<any> {\n  return !!(\n    canUseAsyncIteratorSymbol &&\n    (value as AsyncIterableIterator<any>)[Symbol.asyncIterator]\n  );\n}\n\nfunction isStreamableBlob(value: any): value is Blob {\n  return !!(value as Blob).stream;\n}\n\nfunction isBlob(value: any): value is Blob {\n  return !!(value as Blob).arrayBuffer;\n}\n\nfunction isNodeReadableStream(value: any): value is NodeReadableStream {\n  return !!(value as NodeReadableStream).pipe;\n}\n\nexport function responseIterator<T>(\n  response: Response | NodeResponse\n): AsyncIterableIterator<T> {\n  let body: unknown = response;\n\n  if (isNodeResponse(response)) body = response.body;\n\n  if (isAsyncIterableIterator(body)) return asyncIterator<T>(body);\n\n  if (isReadableStream(body)) return readerIterator<T>(body.getReader());\n\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator<T>(\n      (body.stream() as unknown as ReadableStream<T>).getReader()\n    );\n  }\n\n  if (isBlob(body)) return promiseIterator<T>(body.arrayBuffer());\n\n  if (isNodeReadableStream(body)) return nodeStreamIterator<T>(body);\n\n  throw new Error(\n    \"Unknown body type for responseIterator. Please pass a streamable response.\"\n  );\n}\n", "import \"../utilities/globals/index.js\";\n\nimport type { GraphQLError, GraphQLErrorExtensions } from \"graphql\";\n\nimport { isNonNullObject } from \"../utilities/index.js\";\nimport type { ServerParseError } from \"../link/http/index.js\";\nimport type { ServerError } from \"../link/utils/index.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\n\n// This Symbol allows us to pass transport-specific errors from the link chain\n// into QueryManager/client internals without risking a naming collision within\n// extensions (which implementers can use as they see fit).\nexport const PROTOCOL_ERRORS_SYMBOL: unique symbol = Symbol();\n\ntype FetchResultWithSymbolExtensions<T> = FetchResult<T> & {\n  extensions: Record<string | symbol, any>;\n};\n\nexport interface ApolloErrorOptions {\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  protocolErrors?: ReadonlyArray<{\n    message: string;\n    extensions?: GraphQLErrorExtensions[];\n  }>;\n  clientErrors?: ReadonlyArray<Error>;\n  networkError?: Error | ServerParseError | ServerError | null;\n  errorMessage?: string;\n  extraInfo?: any;\n}\n\nexport function graphQLResultHasProtocolErrors<T>(\n  result: FetchResult<T>\n): result is FetchResultWithSymbolExtensions<T> {\n  if (result.extensions) {\n    return Array.isArray(\n      (result as FetchResultWithSymbolExtensions<T>).extensions[\n        PROTOCOL_ERRORS_SYMBOL\n      ]\n    );\n  }\n  return false;\n}\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty(\"graphQLErrors\");\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  const errors = [\n    ...err.graphQLErrors,\n    ...err.clientErrors,\n    ...err.protocolErrors,\n  ];\n  if (err.networkError) errors.push(err.networkError);\n  return (\n    errors\n      // The rest of the code sometimes unsafely types non-Error objects as GraphQLErrors\n      .map(\n        (err) =>\n          (isNonNullObject(err) && err.message) || \"Error message not found.\"\n      )\n      .join(\"\\n\")\n  );\n};\n\nexport type GraphQLErrors = ReadonlyArray<GraphQLError>;\n\nexport type NetworkError = Error | ServerParseError | ServerError | null;\n\nexport class ApolloError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLErrors;\n  public protocolErrors: ReadonlyArray<{\n    message: string;\n    extensions?: GraphQLErrorExtensions[];\n  }>;\n  public clientErrors: ReadonlyArray<Error>;\n  public networkError: Error | ServerParseError | ServerError | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    protocolErrors,\n    clientErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: ApolloErrorOptions) {\n    super(errorMessage);\n    this.name = \"ApolloError\";\n    this.graphQLErrors = graphQLErrors || [];\n    this.protocolErrors = protocolErrors || [];\n    this.clientErrors = clientErrors || [];\n    this.networkError = networkError || null;\n    this.message = errorMessage || generateErrorMessage(this);\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n", "import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal =\n    contentType?.includes(delimiter) ?\n      contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              if (Object.keys(result).length === 1 && result.payload === null) {\n                return;\n              }\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations) ?\n                operations.map((op) => op.operationName)\n              : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { InvariantError } from \"../../utilities/globals/index.js\";\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport const serializeFetchParameter = (p: any, label: string) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e: any) {\n    const parseError = newInvariantError(\n      `Network request failed. %s is not serializable: %s`,\n      label,\n      e.message\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n", "import type { ASTNode } from \"graphql\";\nimport { print } from \"../../utilities/index.js\";\n\nimport type { Operation } from \"../core/index.js\";\n\nexport interface Printer {\n  (node: ASTNode, originalPrint: typeof print): string;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * If set to true, header names won't be automatically normalized to\n   * lowercase. This allows for non-http-spec-compliant servers that might\n   * expect capitalized header names.\n   */\n  preserveHeaderCase?: boolean;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n\n  /**\n   * If set to true, the default behavior of stripping unused variables\n   * from the request will be disabled.\n   *\n   * Unused variables are likely to trigger server-side validation errors,\n   * per https://spec.graphql.org/draft/#sec-All-Variables-Used, but this\n   * includeUnusedVariables option can be useful if your server deviates\n   * from the GraphQL specification by not strictly enforcing that rule.\n   */\n  includeUnusedVariables?: boolean;\n  /**\n   * A function to substitute for the default query print function. Can be\n   * used to apply changes to the results of the print function.\n   */\n  print?: Printer;\n}\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n  preserveHeaderCase?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: Printer = (ast, printer) => printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: Operation,\n  printer: Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as HttpQueryOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(\n      options.headers,\n      http.preserveHeaderCase\n    );\n  }\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders = Object.create(null);\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData = Object.create(null);\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders = Object.create(null);\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\n\nexport const checkFetcher = (fetcher: typeof fetch | undefined) => {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(`\n\"fetch\" has not been found globally and no fetcher has been \\\nconfigured. To fix this, install a fetch package (like \\\nhttps://www.npmjs.com/package/cross-fetch), instantiate the \\\nfetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    `);\n  }\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === \"undefined\")\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n", "import type { Operation } from \"../core/index.js\";\n\nexport const selectURI = (\n  operation: Operation,\n  fallbackURI?: string | ((operation: Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport type { Body } from \"./selectHttpOptionsAndBody.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        \"Variables map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        \"Extensions map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type { DefinitionNode } from \"graphql\";\n\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport {\n  handleError,\n  readMultipartBody,\n  parseAndCheckHttpResponse,\n} from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport {\n  selectHttpOptionsAndBodyInternal,\n  defaultPrinter,\n  fallbackHttpConfig,\n} from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport {\n  maybe,\n  getMainDefinition,\n  removeClientSetsFromDocument,\n} from \"../../utilities/index.js\";\n\nconst backupFetch = maybe(() => fetch);\n\nexport const createHttpLink = (linkOptions: HttpOptions = {}) => {\n  let {\n    uri = \"/graphql\",\n    // use default global fetch if nothing passed in\n    fetch: preferredFetch,\n    print = defaultPrinter,\n    includeExtensions,\n    preserveHeaderCase,\n    useGETForQueries,\n    includeUnusedVariables = false,\n    ...requestOptions\n  } = linkOptions;\n\n  if (__DEV__) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n\n  const linkConfig = {\n    http: { includeExtensions, preserveHeaderCase },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink((operation) => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders: {\n      \"apollographql-client-name\"?: string;\n      \"apollographql-client-version\"?: string;\n    } = {};\n\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    if (hasDirectives([\"client\"], operation.query)) {\n      const transformedQuery = removeClientSetsFromDocument(operation.query);\n\n      if (!transformedQuery) {\n        return fromError(\n          new Error(\n            \"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"\n          )\n        );\n      }\n\n      operation.query = transformedQuery;\n    }\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBodyInternal(\n      operation,\n      print,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig\n    );\n\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(\n        body.variables,\n        operation.query\n      );\n    }\n\n    let controller: AbortController | undefined;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    const definitionIsSubscription = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    const isSubscription = definitionIsSubscription(\n      getMainDefinition(operation.query)\n    );\n    // does not match custom directives beginning with @defer\n    const hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = \"GET\";\n    }\n\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      let acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        invariant.warn(\"Multipart-subscriptions do not support @defer\");\n      }\n\n      if (isSubscription) {\n        acceptHeader +=\n          \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n\n    if (options.method === \"GET\") {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable((observer) => {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      const currentFetch = preferredFetch || maybe(() => fetch) || backupFetch;\n\n      const observerNext = observer.next.bind(observer);\n      currentFetch!(chosenURI, options)\n        .then((response) => {\n          operation.setContext({ response });\n          const ctype = response.headers?.get(\"content-type\");\n\n          if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n            return readMultipartBody(response, observerNext);\n          } else {\n            return parseAndCheckHttpResponse(operation)(response).then(\n              observerNext\n            );\n          }\n        })\n        .then(() => {\n          controller = undefined;\n          observer.complete();\n        })\n        .catch((err) => {\n          controller = undefined;\n          handleError(err, observer);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n", "import { ApolloLink } from \"../core/index.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\n\nexport class HttpLink extends ApolloLink {\n  constructor(public options: HttpOptions = {}) {\n    super(createHttpLink(options).request);\n  }\n}\n", "/**\n * The current status of a query’s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus?: NetworkStatus\n): boolean {\n  return networkStatus ? networkStatus < 7 : false;\n}\n\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(\n  networkStatus?: NetworkStatus\n): boolean {\n  return networkStatus === 7 || networkStatus === 8;\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  Concast,\n  Observer,\n  ObservableSubscription,\n} from \"../utilities/index.js\";\nimport {\n  cloneDeep,\n  compact,\n  getOperationDefinition,\n  Observable,\n  iterateObserversSafely,\n  fixObservableSubclass,\n  getQueryDefinition,\n} from \"../utilities/index.js\";\nimport type { ApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  NextFetchPolicyContext,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport type { QueryInfo } from \"./QueryInfo.js\";\nimport type { MissingFieldError } from \"../cache/index.js\";\nimport type { MissingTree } from \"../cache/core/types/common.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\n\nconst { assign, hasOwnProperty } = Object;\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables,\n> {\n  updateQuery?: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    }\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\ninterface Last<TData, TVariables> {\n  result: ApolloQueryResult<TData>;\n  variables?: TVariables;\n  error?: ApolloError;\n}\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n> extends Observable<ApolloQueryResult<TData>> {\n  public readonly options: WatchQueryOptions<TVariables, TData>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  public get query(): TypedDocumentNode<TData, TVariables> {\n    return this.lastQuery || this.options.query;\n  }\n\n  // Computed shorthand for this.options.variables, preserved for\n  // backwards compatibility.\n  /**\n   * An object containing the variables that were provided for the query.\n   */\n  public get variables(): TVariables | undefined {\n    return this.options.variables;\n  }\n\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<ObservableSubscription>();\n\n  private waitForOwnResult: boolean;\n  private last?: Last<TData, TVariables>;\n  private lastQuery?: DocumentNode;\n\n  private queryInfo: QueryInfo;\n\n  // When this.concast is defined, this.observer is the Observer currently\n  // subscribed to that Concast.\n  private concast?: Concast<ApolloQueryResult<TData>>;\n  private observer?: Observer<ApolloQueryResult<TData>>;\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  constructor({\n    queryManager,\n    queryInfo,\n    options,\n  }: {\n    queryManager: QueryManager<any>;\n    queryInfo: QueryInfo;\n    options: WatchQueryOptions<TVariables, TData>;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) => {\n      // Zen Observable has its own error function, so in order to log correctly\n      // we need to provide a custom error callback.\n      try {\n        var subObserver = (observer as any)._subscription._observer;\n        if (subObserver && !subObserver.error) {\n          subObserver.error = defaultSubscriptionObserverErrorCallback;\n        }\n      } catch {}\n\n      const first = !this.observers.size;\n      this.observers.add(observer);\n\n      // Deliver most recent error or result.\n      const last = this.last;\n      if (last && last.error) {\n        observer.error && observer.error(last.error);\n      } else if (last && last.result) {\n        observer.next && observer.next(last.result);\n      }\n\n      // Initiate observation of this query if it hasn't been reported to\n      // the QueryManager yet.\n      if (first) {\n        // Blindly catching here prevents unhandled promise rejections,\n        // and is safe because the ObservableQuery handles this error with\n        // this.observer.error, so we're not just swallowing the error by\n        // ignoring it here.\n        this.reobserve().catch(() => {});\n      }\n\n      return () => {\n        if (this.observers.delete(observer) && !this.observers.size) {\n          this.tearDownQuery();\n        }\n      };\n    });\n\n    // related classes\n    this.queryInfo = queryInfo;\n    this.queryManager = queryManager;\n\n    // active state\n    this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n    this.isTornDown = false;\n\n    const {\n      watchQuery: { fetchPolicy: defaultFetchPolicy = \"cache-first\" } = {},\n    } = queryManager.defaultOptions;\n\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : (\n        fetchPolicy\n      ),\n    } = options;\n\n    this.options = {\n      ...options,\n\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n    };\n\n    this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      // TODO: this code doesn’t actually make sense insofar as the observer\n      // will never exist in this.observers due how zen-observable wraps observables.\n      // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  /** @internal */\n  public resetDiff() {\n    this.queryInfo.resetDiff();\n  }\n\n  public getCurrentResult(saveAsLastResult = true): ApolloQueryResult<TData> {\n    // Use the last result as long as the variables match this.variables.\n    const lastResult = this.getLastResult(true);\n\n    const networkStatus =\n      this.queryInfo.networkStatus ||\n      (lastResult && lastResult.networkStatus) ||\n      NetworkStatus.ready;\n\n    const result = {\n      ...lastResult,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<TData>;\n\n    const { fetchPolicy = \"cache-first\" } = this.options;\n    if (\n      // These fetch policies should never deliver data from the cache, unless\n      // redelivering a previously delivered result.\n      skipCacheDataFor(fetchPolicy) ||\n      // If this.options.query has @client(always: true) fields, we cannot\n      // trust diff.result, since it was read from the cache without running\n      // local resolvers (and it's too late to run resolvers now, since we must\n      // return a result synchronously).\n      this.queryManager.getDocumentInfo(this.query).hasForcedResolvers\n    ) {\n      // Fall through.\n    } else if (this.waitForOwnResult) {\n      // This would usually be a part of `QueryInfo.getDiff()`.\n      // which we skip in the waitForOwnResult case since we are not\n      // interested in the diff.\n      this.queryInfo[\"updateWatch\"]();\n    } else {\n      const diff = this.queryInfo.getDiff();\n\n      if (diff.complete || this.options.returnPartialData) {\n        result.data = diff.result;\n      }\n\n      if (equal(result.data, {})) {\n        result.data = void 0 as any;\n      }\n\n      if (diff.complete) {\n        // Similar to setting result.partial to false, but taking advantage of the\n        // falsiness of missing fields.\n        delete result.partial;\n\n        // If the diff is complete, and we're using a FetchPolicy that\n        // terminates after a complete cache read, we can assume the next result\n        // we receive will have NetworkStatus.ready and !loading.\n        if (\n          diff.complete &&\n          result.networkStatus === NetworkStatus.loading &&\n          (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")\n        ) {\n          result.networkStatus = NetworkStatus.ready;\n          result.loading = false;\n        }\n      } else {\n        result.partial = true;\n      }\n\n      if (\n        __DEV__ &&\n        !diff.complete &&\n        !this.options.partialRefetch &&\n        !result.loading &&\n        !result.data &&\n        !result.error\n      ) {\n        logMissingFieldErrors(diff.missing);\n      }\n    }\n\n    if (saveAsLastResult) {\n      this.updateLastResult(result);\n    }\n\n    return result;\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(\n    newResult: ApolloQueryResult<TData>,\n    variables?: TVariables\n  ) {\n    if (!this.last) {\n      return true;\n    }\n\n    const resultIsDifferent =\n      this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ?\n        !equalByQuery(this.query, this.last.result, newResult, this.variables)\n      : !equal(this.last.result, newResult);\n\n    return (\n      resultIsDifferent || (variables && !equal(this.last.variables, variables))\n    );\n  }\n\n  private getLast<K extends keyof Last<TData, TVariables>>(\n    key: K,\n    variablesMustMatch?: boolean\n  ) {\n    const last = this.last;\n    if (\n      last &&\n      last[key] &&\n      (!variablesMustMatch || equal(last.variables, this.variables))\n    ) {\n      return last[key];\n    }\n  }\n\n  public getLastResult(\n    variablesMustMatch?: boolean\n  ): ApolloQueryResult<TData> | undefined {\n    return this.getLast(\"result\", variablesMustMatch);\n  }\n\n  public getLastError(variablesMustMatch?: boolean): ApolloError | undefined {\n    return this.getLast(\"error\", variablesMustMatch);\n  }\n\n  public resetLastResults(): void {\n    delete this.last;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    this.queryManager.resetErrors(this.queryId);\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(\n    variables?: Partial<TVariables>\n  ): Promise<ApolloQueryResult<TData>> {\n    const reobserveOptions: Partial<WatchQueryOptions<TVariables, TData>> = {\n      // Always disable polling for refetches.\n      pollInterval: 0,\n    };\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    const { fetchPolicy } = this.options;\n    if (fetchPolicy === \"cache-and-network\") {\n      reobserveOptions.fetchPolicy = fetchPolicy;\n    } else if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some((v) => v.variable.name.value === \"variables\")) {\n        invariant.warn(\n          `Called refetch(%o) for query %o, which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?`,\n          variables,\n          queryDef.name?.value || queryDef\n        );\n      }\n    }\n\n    if (variables && !equal(this.options.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = {\n        ...this.options.variables,\n        ...variables,\n      } as TVariables;\n    }\n\n    this.queryInfo.resetLastWrite();\n    return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n  }\n\n  /**\n   * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n   */\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >(\n    fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {\n      updateQuery?: (\n        previousQueryResult: TData,\n        options: {\n          fetchMoreResult: TFetchData;\n          variables: TFetchVars;\n        }\n      ) => TData;\n    }\n  ): Promise<ApolloQueryResult<TFetchData>> {\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : (\n        {\n          ...this.options,\n          query: this.options.query,\n          ...fetchMoreOptions,\n          variables: {\n            ...this.options.variables,\n            ...fetchMoreOptions.variables,\n          },\n        }\n      )),\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n    } as WatchQueryOptions<TFetchVars, TFetchData>;\n\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n\n    const qid = this.queryManager.generateQueryId();\n\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery =\n      fetchMoreOptions.query ?\n        this.transformDocument(this.options.query)\n      : combinedOptions.query;\n\n    // Simulate a loading result for the original query with\n    // result.networkStatus === NetworkStatus.fetchMore.\n    const { queryInfo } = this;\n    const originalNetworkStatus = queryInfo.networkStatus;\n    queryInfo.networkStatus = NetworkStatus.fetchMore;\n    if (combinedOptions.notifyOnNetworkStatusChange) {\n      this.observe();\n    }\n\n    const updatedQuerySet = new Set<DocumentNode>();\n\n    return this.queryManager\n      .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\n      .then((fetchMoreResult) => {\n        this.queryManager.removeQuery(qid);\n\n        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n          queryInfo.networkStatus = originalNetworkStatus;\n        }\n\n        // Performing this cache update inside a cache.batch transaction ensures\n        // any affected cache.watch watchers are notified at most once about any\n        // updates. Most watchers will be using the QueryInfo class, which\n        // responds to notifications by calling reobserveCacheFirst to deliver\n        // fetchMore cache results back to this ObservableQuery.\n        this.queryManager.cache.batch({\n          update: (cache) => {\n            const { updateQuery } = fetchMoreOptions;\n            if (updateQuery) {\n              cache.updateQuery(\n                {\n                  query: this.query,\n                  variables: this.variables,\n                  returnPartialData: true,\n                  optimistic: false,\n                },\n                (previous) =>\n                  updateQuery(previous!, {\n                    fetchMoreResult: fetchMoreResult.data,\n                    variables: combinedOptions.variables as TFetchVars,\n                  })\n              );\n            } else {\n              // If we're using a field policy instead of updateQuery, the only\n              // thing we need to do is write the new data to the cache using\n              // combinedOptions.variables (instead of this.variables, which is\n              // what this.updateQuery uses, because it works by abusing the\n              // original field value, keyed by the original variables).\n              cache.writeQuery({\n                query: combinedOptions.query,\n                variables: combinedOptions.variables,\n                data: fetchMoreResult.data,\n              });\n            }\n          },\n\n          onWatchUpdated: (watch) => {\n            // Record the DocumentNode associated with any watched query whose\n            // data were updated by the cache writes above.\n            updatedQuerySet.add(watch.query);\n          },\n        });\n\n        return fetchMoreResult;\n      })\n      .finally(() => {\n        // In case the cache writes above did not generate a broadcast\n        // notification (which would have been intercepted by onWatchUpdated),\n        // likely because the written data were the same as what was already in\n        // the cache, we still want fetchMore to deliver its final loading:false\n        // result with the unchanged data.\n        if (!updatedQuerySet.has(this.query)) {\n          reobserveCacheFirst(this);\n        }\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables extends OperationVariables = TVariables,\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                })\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error(\"Unhandled GraphQL subscription error\", err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  public setOptions(\n    newOptions: Partial<WatchQueryOptions<TVariables, TData>>\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.reobserve(newOptions);\n  }\n\n  public silentSetOptions(\n    newOptions: Partial<WatchQueryOptions<TVariables, TData>>\n  ) {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public setVariables(\n    variables: TVariables\n  ): Promise<ApolloQueryResult<TData> | void> {\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size ? this.result() : Promise.resolve();\n    }\n\n    this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    return this.reobserve(\n      {\n        // Reset options.fetchPolicy to its original value.\n        fetchPolicy: this.options.initialFetchPolicy,\n        variables,\n      },\n      NetworkStatus.setVariables\n    );\n  }\n\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  public updateQuery<TVars extends OperationVariables = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: Pick<WatchQueryOptions<TVars, TData>, \"variables\">\n    ) => TData\n  ): void {\n    const { queryManager } = this;\n    const { result } = queryManager.cache.diff<TData>({\n      query: this.options.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic: false,\n    });\n\n    const newResult = mapFn(result!, {\n      variables: (this as any).variables,\n    });\n\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables,\n      });\n\n      queryManager.broadcastQueries();\n    }\n  }\n\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  public startPolling(pollInterval: number) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  public stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  private applyNextFetchPolicy(\n    reason: NextFetchPolicyContext<TData, TVariables>[\"reason\"],\n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options: WatchQueryOptions<TVariables, TData>\n  ) {\n    if (options.nextFetchPolicy) {\n      const { fetchPolicy = \"cache-first\", initialFetchPolicy = fetchPolicy } =\n        options;\n\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.setOptions.\n        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n          reason,\n          options,\n          observable: this,\n          initialFetchPolicy,\n        });\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n\n    return options.fetchPolicy;\n  }\n\n  private fetch(\n    options: WatchQueryOptions<TVariables, TData>,\n    newNetworkStatus?: NetworkStatus,\n    query?: DocumentNode\n  ) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    this.queryManager.setObservableQuery(this);\n    return this.queryManager[\"fetchConcastWithInfo\"](\n      this.queryId,\n      options,\n      newNetworkStatus,\n      query\n    );\n  }\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    const {\n      pollingInfo,\n      options: { pollInterval },\n    } = this;\n\n    if (!pollInterval || !this.hasObservers()) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      \"Attempted to start a polling query without a polling interval.\"\n    );\n\n    const info = pollingInfo || (this.pollingInfo = {} as any);\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (\n          !isNetworkRequestInFlight(this.queryInfo.networkStatus) &&\n          !this.options.skipPollAttempt?.()\n        ) {\n          this.reobserve(\n            {\n              // Most fetchPolicy options don't make sense to use in a polling context, as\n              // users wouldn't want to be polling the cache directly. However, network-only and\n              // no-cache are both useful for when the user wants to control whether or not the\n              // polled results are written to the cache.\n              fetchPolicy:\n                this.options.initialFetchPolicy === \"no-cache\" ?\n                  \"no-cache\"\n                : \"network-only\",\n            },\n            NetworkStatus.poll\n          ).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n\n  private updateLastResult(\n    newResult: ApolloQueryResult<TData>,\n    variables = this.variables\n  ) {\n    let error: ApolloError | undefined = this.getLastError();\n    // Preserve this.last.error unless the variables have changed.\n    if (error && this.last && !equal(variables, this.last.variables)) {\n      error = void 0;\n    }\n    return (this.last = {\n      result:\n        this.queryManager.assumeImmutableResults ?\n          newResult\n        : cloneDeep(newResult),\n      variables,\n      ...(error ? { error } : null),\n    });\n  }\n\n  public reobserveAsConcast(\n    newOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n    newNetworkStatus?: NetworkStatus\n  ): Concast<ApolloQueryResult<TData>> {\n    this.isTornDown = false;\n\n    const useDisposableConcast =\n      // Refetching uses a disposable Concast to allow refetches using different\n      // options/variables, without permanently altering the options of the\n      // original ObservableQuery.\n      newNetworkStatus === NetworkStatus.refetch ||\n      // The fetchMore method does not actually call the reobserve method, but,\n      // if it did, it would definitely use a disposable Concast.\n      newNetworkStatus === NetworkStatus.fetchMore ||\n      // Polling uses a disposable Concast so the polling options (which force\n      // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n      newNetworkStatus === NetworkStatus.poll;\n\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.options.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n\n    const mergedOptions = compact(this.options, newOptions || {});\n    const options =\n      useDisposableConcast ?\n        // Disposable Concast fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions\n      : assign(this.options, mergedOptions);\n\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n\n    this.lastQuery = query;\n\n    if (!useDisposableConcast) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (\n        newOptions &&\n        newOptions.variables &&\n        !equal(newOptions.variables, oldVariables) &&\n        // Don't mess with the fetchPolicy if it's currently \"standby\".\n        options.fetchPolicy !== \"standby\" &&\n        // If we're changing the fetchPolicy anyway, don't try to change it here\n        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n        options.fetchPolicy === oldFetchPolicy\n      ) {\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    this.waitForOwnResult &&= skipCacheDataFor(options.fetchPolicy);\n    const finishWaitingForOwnResult = () => {\n      if (this.concast === concast) {\n        this.waitForOwnResult = false;\n      }\n    };\n\n    const variables = options.variables && { ...options.variables };\n    const { concast, fromLink } = this.fetch(options, newNetworkStatus, query);\n    const observer: Observer<ApolloQueryResult<TData>> = {\n      next: (result) => {\n        if (equal(this.variables, variables)) {\n          finishWaitingForOwnResult();\n          this.reportResult(result, variables);\n        }\n      },\n      error: (error) => {\n        if (equal(this.variables, variables)) {\n          finishWaitingForOwnResult();\n          this.reportError(error, variables);\n        }\n      },\n    };\n\n    if (!useDisposableConcast && (fromLink || !this.concast)) {\n      // We use the {add,remove}Observer methods directly to avoid wrapping\n      // observer with an unnecessary SubscriptionObserver object.\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer);\n      }\n\n      this.concast = concast;\n      this.observer = observer;\n    }\n\n    concast.addObserver(observer);\n\n    return concast;\n  }\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n    newNetworkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.reobserveAsConcast(newOptions, newNetworkStatus)\n      .promise as TODO;\n  }\n\n  public resubscribeAfterError(\n    onNext: (value: ApolloQueryResult<TData>) => void,\n    onError?: (error: any) => void,\n    onComplete?: () => void\n  ): ObservableSubscription;\n\n  public resubscribeAfterError(\n    observer: Observer<ApolloQueryResult<TData>>\n  ): ObservableSubscription;\n\n  public resubscribeAfterError(...args: [any, any?, any?]) {\n    // If `lastError` is set in the current when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore the last value afterwards so that the\n    // subscription has a chance to stay open.\n    const last = this.last;\n    this.resetLastResults();\n\n    const subscription = this.subscribe(...args);\n    this.last = last;\n\n    return subscription;\n  }\n\n  // (Re)deliver the current result to this.observers without applying fetch\n  // policies or making network requests.\n  private observe() {\n    this.reportResult(\n      // Passing false is important so that this.getCurrentResult doesn't\n      // save the fetchMore result as this.lastResult, causing it to be\n      // ignored due to the this.isDifferentFromLastResult check in\n      // this.reportResult.\n      this.getCurrentResult(false),\n      this.variables\n    );\n  }\n\n  private reportResult(\n    result: ApolloQueryResult<TData>,\n    variables: TVariables | undefined\n  ) {\n    const lastError = this.getLastError();\n    const isDifferent = this.isDifferentFromLastResult(result, variables);\n    // Update the last result even when isDifferentFromLastResult returns false,\n    // because the query may be using the @nonreactive directive, and we want to\n    // save the the latest version of any nonreactive subtrees (in case\n    // getCurrentResult is called), even though we skip broadcasting changes.\n    if (lastError || !result.partial || this.options.returnPartialData) {\n      this.updateLastResult(result, variables);\n    }\n    if (lastError || isDifferent) {\n      iterateObserversSafely(this.observers, \"next\", result);\n    }\n  }\n\n  private reportError(error: ApolloError, variables: TVariables | undefined) {\n    // Since we don't get the current result on errors, only the error, we\n    // must mirror the updates that occur in QueryStore.markQueryError here\n    const errorResult = {\n      ...this.getLastResult(),\n      error,\n      errors: error.graphQLErrors,\n      networkStatus: NetworkStatus.error,\n      loading: false,\n    } as ApolloQueryResult<TData>;\n\n    this.updateLastResult(errorResult, variables);\n\n    iterateObserversSafely(this.observers, \"error\", (this.last!.error = error));\n  }\n\n  public hasObservers() {\n    return this.observers.size > 0;\n  }\n\n  private tearDownQuery() {\n    if (this.isTornDown) return;\n    if (this.concast && this.observer) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n      delete this.observer;\n    }\n\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach((sub) => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n    this.isTornDown = true;\n  }\n\n  private transformDocument(document: DocumentNode) {\n    return this.queryManager.transform(document);\n  }\n}\n\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nexport function reobserveCacheFirst<TData, TVars extends OperationVariables>(\n  obsQuery: ObservableQuery<TData, TVars>\n) {\n  const { fetchPolicy, nextFetchPolicy } = obsQuery.options;\n\n  if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n    return obsQuery.reobserve({\n      fetchPolicy: \"cache-first\",\n      // Use a temporary nextFetchPolicy function that replaces itself with the\n      // previous nextFetchPolicy value and returns the original fetchPolicy.\n      nextFetchPolicy(\n        this: WatchQueryOptions<TVars, TData>,\n        currentFetchPolicy: WatchQueryFetchPolicy,\n        context: NextFetchPolicyContext<TData, TVars>\n      ) {\n        // Replace this nextFetchPolicy function in the options object with the\n        // original this.options.nextFetchPolicy value.\n        this.nextFetchPolicy = nextFetchPolicy;\n        // If the original nextFetchPolicy value was a function, give it a\n        // chance to decide what happens here.\n        if (typeof this.nextFetchPolicy === \"function\") {\n          return this.nextFetchPolicy(currentFetchPolicy, context);\n        }\n        // Otherwise go back to the original this.options.fetchPolicy.\n        return fetchPolicy!;\n      },\n    });\n  }\n\n  return obsQuery.reobserve();\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error(\"Unhandled error\", error.message, error.stack);\n}\n\nexport function logMissingFieldErrors(\n  missing: MissingFieldError[] | MissingTree | undefined\n) {\n  if (__DEV__ && missing) {\n    invariant.debug(`Missing cache result fields: %o`, missing);\n  }\n}\n\nfunction skipCacheDataFor(\n  fetchPolicy?: WatchQueryFetchPolicy /* `undefined` would mean `\"cache-first\"` */\n) {\n  return (\n    fetchPolicy === \"network-only\" ||\n    fetchPolicy === \"no-cache\" ||\n    fetchPolicy === \"standby\"\n  );\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client?: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher?: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher | undefined {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables<TVars extends OperationVariables>(\n    document: DocumentNode,\n    variables: TVars = {} as TVars,\n    context = {}\n  ): /* returns at least the variables that were passed in */ Promise<TVars> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType =\n      definitionOperation ?\n        definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n", "import type { DocumentNode, GraphQLError } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport type { WatchQueryOptions, ErrorPolicy } from \"./watchQueryOptions.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport { reobserveCacheFirst } from \"./ObservableQuery.js\";\nimport type { QueryListener } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport {\n  isNonEmptyArray,\n  graphQLResultHasError,\n  canUseWeakMap,\n} from \"../utilities/index.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type { ApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\n\nexport type QueryStoreValue = Pick<\n  QueryInfo,\n  \"variables\" | \"networkStatus\" | \"networkError\" | \"graphQLErrors\"\n>;\n\nexport const enum CacheWriteBehavior {\n  FORBID,\n  OVERWRITE,\n  MERGE,\n}\n\nconst destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)<\n  ApolloCache<any>,\n  number\n>();\n\nfunction wrapDestructiveCacheMethod(\n  cache: ApolloCache<any>,\n  methodName: \"evict\" | \"modify\" | \"reset\"\n) {\n  const original = cache[methodName];\n  if (typeof original === \"function\") {\n    // @ts-expect-error this is just too generic to be typed correctly\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(\n        cache,\n        // The %1e15 allows the count to wrap around to 0 safely every\n        // quadrillion evictions, so there's no risk of overflow. To be\n        // clear, this is more of a pedantic principle than something\n        // that matters in any conceivable practical scenario.\n        (destructiveMethodCounts.get(cache)! + 1) % 1e15\n      );\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\n\nfunction cancelNotifyTimeout(info: QueryInfo) {\n  if (info[\"notifyTimeout\"]) {\n    clearTimeout(info[\"notifyTimeout\"]);\n    info[\"notifyTimeout\"] = void 0;\n  }\n}\n\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nexport class QueryInfo {\n  listeners = new Set<QueryListener>();\n  document: DocumentNode | null = null;\n  lastRequestId = 1;\n  variables?: Record<string, any>;\n  networkStatus?: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  stopped = false;\n\n  private cache: ApolloCache<any>;\n\n  constructor(\n    queryManager: QueryManager<any>,\n    public readonly queryId = queryManager.generateQueryId()\n  ) {\n    const cache = (this.cache = queryManager.cache);\n\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n\n  public init(query: {\n    document: DocumentNode;\n    variables: Record<string, any> | undefined;\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus?: NetworkStatus;\n    observableQuery?: ObservableQuery<any, any>;\n    lastRequestId?: number;\n  }): this {\n    let networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (\n      this.variables &&\n      this.networkStatus !== NetworkStatus.loading &&\n      !equal(this.variables, query.variables)\n    ) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n    }\n\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus,\n    });\n\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n\n    return this;\n  }\n\n  private dirty: boolean = false;\n\n  private notifyTimeout?: ReturnType<typeof setTimeout>;\n\n  reset() {\n    cancelNotifyTimeout(this);\n    this.dirty = false;\n  }\n\n  resetDiff() {\n    this.lastDiff = void 0;\n  }\n\n  getDiff(): Cache.DiffResult<any> {\n    const options = this.getDiffOptions();\n\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n\n    this.updateWatch(this.variables);\n\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return { complete: false };\n    }\n\n    const diff = this.cache.diff(options);\n    this.updateLastDiff(diff, options);\n    return diff;\n  }\n\n  private lastDiff?: {\n    diff: Cache.DiffResult<any>;\n    options: Cache.DiffOptions;\n  };\n\n  private updateLastDiff(\n    diff: Cache.DiffResult<any> | null,\n    options?: Cache.DiffOptions\n  ) {\n    this.lastDiff =\n      diff ?\n        {\n          diff,\n          options: options || this.getDiffOptions(),\n        }\n      : void 0;\n  }\n\n  private getDiffOptions(variables = this.variables): Cache.DiffOptions {\n    return {\n      query: this.document!,\n      variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: this.observableQuery?.options.canonizeResults,\n    };\n  }\n\n  setDiff(diff: Cache.DiffResult<any> | null) {\n    const oldDiff = this.lastDiff && this.lastDiff.diff;\n\n    // If we are trying to deliver an incomplete cache result, we avoid\n    // reporting it if the query has errored, otherwise we let the broadcast try\n    // and repair the partial result by refetching the query. This check avoids\n    // a situation where a query that errors and another succeeds with\n    // overlapping data does not report the partial data result to the errored\n    // query.\n    //\n    // See https://github.com/apollographql/apollo-client/issues/11400 for more\n    // information on this issue.\n    if (diff && !diff.complete && this.observableQuery?.getLastError()) {\n      return;\n    }\n\n    this.updateLastDiff(diff);\n\n    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      this.dirty = true;\n      if (!this.notifyTimeout) {\n        this.notifyTimeout = setTimeout(() => this.notify(), 0);\n      }\n    }\n  }\n\n  public readonly observableQuery: ObservableQuery<any, any> | null = null;\n  private oqListener?: QueryListener;\n\n  setObservableQuery(oq: ObservableQuery<any, any> | null) {\n    if (oq === this.observableQuery) return;\n\n    if (this.oqListener) {\n      this.listeners.delete(this.oqListener);\n    }\n\n    (this as any).observableQuery = oq;\n\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n      this.listeners.add(\n        (this.oqListener = () => {\n          const diff = this.getDiff();\n          if (diff.fromOptimisticTransaction) {\n            // If this diff came from an optimistic transaction, deliver the\n            // current cache data to the ObservableQuery, but don't perform a\n            // reobservation, since oq.reobserveCacheFirst might make a network\n            // request, and we never want to trigger network requests in the\n            // middle of optimistic updates.\n            oq[\"observe\"]();\n          } else {\n            // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n            // using a temporary fetch policy of \"cache-first\", so complete cache\n            // results have a chance to be delivered without triggering additional\n            // network requests, even when options.fetchPolicy is \"network-only\"\n            // or \"cache-and-network\". All other fetch policies are preserved by\n            // this method, and are handled by calling oq.reobserve(). If this\n            // reobservation is spurious, isDifferentFromLastResult still has a\n            // chance to catch it before delivery to ObservableQuery subscribers.\n            reobserveCacheFirst(oq);\n          }\n        })\n      );\n    } else {\n      delete this.oqListener;\n    }\n  }\n\n  notify() {\n    cancelNotifyTimeout(this);\n\n    if (this.shouldNotify()) {\n      this.listeners.forEach((listener) => listener(this));\n    }\n\n    this.dirty = false;\n  }\n\n  private shouldNotify() {\n    if (!this.dirty || !this.listeners.size) {\n      return false;\n    }\n\n    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {\n      const { fetchPolicy } = this.observableQuery.options;\n      if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public stop() {\n    if (!this.stopped) {\n      this.stopped = true;\n\n      // Cancel the pending notify timeout\n      this.reset();\n\n      this.cancel();\n      // Revert back to the no-op version of cancel inherited from\n      // QueryInfo.prototype.\n      this.cancel = QueryInfo.prototype.cancel;\n\n      const oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  }\n\n  // This method is a no-op by default, until/unless overridden by the\n  // updateWatch method.\n  private cancel() {}\n\n  private lastWatch?: Cache.WatchOptions;\n\n  private updateWatch(variables = this.variables) {\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n\n    const watchOptions: Cache.WatchOptions = {\n      // Although this.getDiffOptions returns Cache.DiffOptions instead of\n      // Cache.WatchOptions, all the overlapping options should be the same, so\n      // we can reuse getDiffOptions here, for consistency.\n      ...this.getDiffOptions(variables),\n      watcher: this,\n      callback: (diff) => this.setDiff(diff),\n    };\n\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancel = this.cache.watch((this.lastWatch = watchOptions));\n    }\n  }\n\n  private lastWrite?: {\n    result: FetchResult<any>;\n    variables: WatchQueryOptions[\"variables\"];\n    dmCount: number | undefined;\n  };\n\n  public resetLastWrite() {\n    this.lastWrite = void 0;\n  }\n\n  private shouldWrite(\n    result: FetchResult<any>,\n    variables: WatchQueryOptions[\"variables\"]\n  ) {\n    const { lastWrite } = this;\n    return !(\n      lastWrite &&\n      // If cache.evict has been called since the last time we wrote this\n      // data into the cache, there's a chance writing this result into\n      // the cache will repair what was evicted.\n      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n      equal(variables, lastWrite.variables) &&\n      equal(result.data, lastWrite.result.data)\n    );\n  }\n\n  public markResult<T>(\n    result: FetchResult<T>,\n    document: DocumentNode,\n    options: Pick<\n      WatchQueryOptions,\n      \"variables\" | \"fetchPolicy\" | \"errorPolicy\"\n    >,\n    cacheWriteBehavior: CacheWriteBehavior\n  ) {\n    const merger = new DeepMerger();\n    const graphQLErrors =\n      isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.reset();\n\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      const mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      const diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n\n    this.graphQLErrors = graphQLErrors;\n\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff(\n        { result: result.data, complete: true },\n        this.getDiffOptions(options.variables)\n      );\n    } else if (cacheWriteBehavior !== CacheWriteBehavior.FORBID) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction((cache) => {\n          if (this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data as T,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === CacheWriteBehavior.OVERWRITE,\n            });\n\n            this.lastWrite = {\n              result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(this.cache),\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (this.lastDiff && this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          const diffOptions = this.getDiffOptions(options.variables);\n          const diff = cache.diff<T>(diffOptions);\n\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!this.stopped && equal(this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            this.updateWatch(options.variables);\n          }\n\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  }\n\n  public markReady() {\n    this.networkError = null;\n    return (this.networkStatus = NetworkStatus.ready);\n  }\n\n  public markError(error: ApolloError) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n\n    this.reset();\n\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n\n    return error;\n  }\n}\n\nexport function shouldWriteResult<T>(\n  result: FetchResult<T>,\n  errorPolicy: ErrorPolicy = \"none\"\n) {\n  const ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  let writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n", "import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode } from \"graphql\";\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from \"@wry/equality\";\n\nimport type { ApolloLink, FetchResult } from \"../link/core/index.js\";\nimport { execute } from \"../link/core/index.js\";\nimport {\n  defaultCacheSizes,\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  removeDirectivesFromDocument,\n} from \"../utilities/index.js\";\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray,\n} from \"../utilities/index.js\";\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport {\n  ApolloError,\n  isApolloError,\n  graphQLResultHasProtocolErrors,\n} from \"../errors/index.js\";\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n  DefaultContext,\n} from \"./types.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nimport type { QueryStoreValue } from \"./QueryInfo.js\";\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from \"./QueryInfo.js\";\nimport type { ApolloErrorOptions } from \"../errors/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nimport type { IgnoreModifier } from \"../cache/core/types/common.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst IGNORE: IgnoreModifier = Object.create(null);\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nimport type { DefaultOptions } from \"./ApolloClient.js\";\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    defaultOptions,\n    documentTransform,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults = !!cache.assumeImmutableResults,\n    defaultContext,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    defaultOptions?: DefaultOptions;\n    documentTransform?: DocumentTransform;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n    defaultContext?: Partial<DefaultContext>;\n  }) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = cache;\n    this.link = link;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = assumeImmutableResults;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = defaultContext || Object.create(null);\n\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<\n    FetchResult<TData>\n  > {\n    invariant(\n      mutation,\n      \"mutation option is required. You must specify your GraphQL document in the mutation option.\"\n    );\n\n    invariant(\n      fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\",\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = (await this.localState.addExportedVariables(\n        mutation,\n        variables,\n        context\n      )) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      this.markMutationOptimistic<TData, TVariables, TContext, TCache>(\n        optimisticResponse,\n        {\n          mutationId,\n          document: mutation,\n          variables,\n          fetchPolicy,\n          errorPolicy,\n          context,\n          updateQueries,\n          update: updateWithProxyFn,\n          keepRootFields,\n        }\n      );\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n          },\n          variables,\n          false\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(storeResult);\n          }\n\n          if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<TData, TVariables, TContext, TCache>({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: isOptimistic ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        }\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n            resolve(storeResult);\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (isOptimistic) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : (\n              new ApolloError({\n                networkError: err,\n              })\n            )\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (\n        isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)\n      ) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables,\n          });\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: (document && getOperationName(document)) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      (mutation.refetchQueries || \"\").length > 0 ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache) => {\n          if (!skipCache) {\n            cacheWrites.forEach((write) => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...(result as FetchResult), data: diff.result };\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache as TCache, result, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n      }).forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\" ?\n        optimisticResponse(mutation.variables, { IGNORE })\n      : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>(\n          {\n            ...mutation,\n            result: { data },\n          },\n          cache\n        );\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n\n    return true;\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n      .promise as TODO;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n          ],\n          document\n        ),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<\n    T,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable[\"lastQuery\"] = query;\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId()\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      \"query option is required. You must specify your GraphQL document \" +\n        \"in the query option.\"\n    );\n\n    invariant(\n      options.query.kind === \"Document\",\n      'You must wrap the query string in a \"gql\" tag.'\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      \"returnPartialData option only supported on watchQuery.\"\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      \"pollInterval option only supported on watchQuery.\"\n    );\n\n    return this.fetchQuery<TData, TVars>(queryId, {\n      ...options,\n      query: this.transform(options.query),\n    }).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.queries.forEach((queryInfo) => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNamesAndDocs = new Map<string | DocumentNode, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(this.transform(desc), false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndDocs.has(queryName)) ||\n          (document && queryNamesAndDocs.has(document))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach((included, nameOrDoc) => {\n        if (!included) {\n          invariant.warn(\n            typeof nameOrDoc === \"string\" ?\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`\n            : `Unknown query %o requested in refetchQueries options.include array`,\n            nameOrDoc\n          );\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery, queryId) => {\n        const { fetchPolicy } = observableQuery.options;\n        observableQuery.resetLastResults();\n        if (\n          includeStandby ||\n          (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        this.getQuery(queryId).setDiff(null);\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy = \"none\",\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(query, context, variables).map((result) => {\n        if (fetchPolicy !== \"no-cache\") {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: \"ROOT_SUBSCRIPTION\",\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        const hasErrors = graphQLResultHasError(result);\n        const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          const errors: ApolloErrorOptions = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n\n          // `errorPolicy` is a mechanism for handling GraphQL errors, according\n          // to our documentation, so we throw protocol errors regardless of the\n          // set error policy.\n          if (errorPolicy === \"none\" || hasProtocolErrors) {\n            throw new ApolloError(errors);\n          }\n        }\n\n        if (errorPolicy === \"ignore\") {\n          delete result.errors;\n        }\n\n        return result;\n      });\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState\n        .addExportedVariables(query, variables, context)\n        .then(makeObservable);\n\n      return new Observable<FetchResult<T>>((observer) => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          (observable) => (sub = observable.subscribe(observer)),\n          observer.error\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach((info) => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<FetchResult<any>>;\n  }>(false);\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>> | undefined;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication,\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const varJson = canonicalStringify(variables);\n\n        const entry = inFlightLinkObservables.lookup(\n          printedServerQuery,\n          varJson\n        );\n\n        observable = entry.observable;\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>,\n          ]);\n          observable = entry.observable = concast;\n\n          concast.beforeNext(() => {\n            inFlightLinkObservables.remove(printedServerQuery, varJson);\n          });\n        }\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>,\n        ]);\n      }\n    } else {\n      observable = new Concast([Observable.of({ data: {} } as FetchResult<T>)]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, (result) => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<\n      WatchQueryOptions<TVars, TData>,\n      \"query\" | \"variables\" | \"context\" | \"fetchPolicy\" | \"errorPolicy\"\n    >\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables\n      ),\n\n      (result) => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(\n              new ApolloError({\n                graphQLErrors,\n              })\n            );\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(\n            result,\n            linkDocument,\n            options,\n            cacheWriteBehavior\n          );\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      (networkError) => {\n        const error =\n          isApolloError(networkError) ? networkError : (\n            new ApolloError({ networkError })\n          );\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      }\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query\n  ): ConcastAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options\n        );\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryId);\n    this.fetchCancelFns.set(queryId, (reason) => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n      containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(\n            normalized.query,\n            normalized.variables,\n            normalized.context\n          )\n          .then(fromVariables)\n          .then((sourcesWithInfo) => sourcesWithInfo.sources)\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache<TStore>,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<\n      string,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloQueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    {\n      query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff();\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) =>\n        Observable.of({\n          data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          ...(diff.complete ? null : { partial: true }),\n        } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState\n          .runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n          })\n          .then((resolved) => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n        // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : (\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ?\n        CacheWriteBehavior.OVERWRITE\n      : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(diff, queryInfo.markReady())],\n          };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...this.defaultContext,\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n", "import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { ExecutionResult, DocumentNode } from \"graphql\";\n\nimport type { FetchResult, GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform, Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  ApolloQueryResult,\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport interface ApolloClientOptions<TCacheShape> {\n  /**\n   * The URI of the GraphQL endpoint that Apollo Client will communicate with.\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  uri?: string | UriFunction;\n  credentials?: string;\n  /**\n   * An object representing headers to include in every HTTP request, such as `{Authorization: 'Bearer 1234'}`\n   *\n   * This value will be ignored when using the `link` option.\n   */\n  headers?: Record<string, string>;\n  /**\n   * You can provide an `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  link?: ApolloLink;\n  /**\n   * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n   *\n   * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n   */\n  cache: ApolloCache<TCacheShape>;\n  /**\n   * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n   *\n   * @defaultValue `0` (no delay)\n   */\n  ssrForceFetchDelay?: number;\n  /**\n   * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n   *\n   * @defaultValue `false`\n   */\n  ssrMode?: boolean;\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to Apollo Client.\n   *\n   * The default value is `false` in production and `true` in development (if there is a `window` object).\n   */\n  connectToDevTools?: boolean;\n  /**\n   * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n   *\n   * @defaultValue `true`\n   */\n  queryDeduplication?: boolean;\n  /**\n   * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n   *\n   * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n   */\n  defaultOptions?: DefaultOptions;\n  defaultContext?: Partial<DefaultContext>;\n  /**\n   * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n   *\n   * @defaultValue `false`\n   */\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  /**\n   * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   */\n  name?: string;\n  /**\n   * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n   */\n  version?: string;\n  documentTransform?: DocumentTransform;\n}\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nimport type {\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/core/cache.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools = typeof window === \"object\" &&\n        !(window as any).__APOLLO_CLIENT__ &&\n        __DEV__,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link =\n        uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast:\n        connectToDevTools ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (connectToDevTools) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"object\") {\n      type DevToolsConnector = {\n        push(client: ApolloClient<any>): void;\n      };\n      const windowWithDevTools = window as Window & {\n        [devtoolsSymbol]?: DevToolsConnector;\n        __APOLLO_CLIENT__?: ApolloClient<any>;\n      };\n      const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n      (windowWithDevTools[devtoolsSymbol] =\n        windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n        this\n      );\n      windowWithDevTools.__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      setTimeout(() => {\n        if (\n          typeof window !== \"undefined\" &&\n          window.document &&\n          window.top === window.self &&\n          !(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ &&\n          /^(https?|file):$/.test(window.location.protocol)\n        ) {\n          const nav = window.navigator;\n          const ua = nav && nav.userAgent;\n          let url: string | undefined;\n          if (typeof ua === \"string\") {\n            if (ua.indexOf(\"Chrome/\") > -1) {\n              url =\n                \"https://chrome.google.com/webstore/detail/\" +\n                \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n            } else if (ua.indexOf(\"Firefox/\") > -1) {\n              url =\n                \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n            }\n          }\n          if (url) {\n            invariant.log(\n              \"Download the Apollo DevTools for a better development \" +\n                \"experience: %s\",\n              url\n            );\n          }\n        }\n      }, 10000);\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: QueryOptions<TVariables, T>): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<FetchResult<TData>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: SubscriptionOptions<TVariables, T>): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n\n  public watchFragment<\n    TFragmentData = unknown,\n    TVariables = OperationVariables,\n  >(\n    options: WatchFragmentOptions<TFragmentData, TVariables>\n  ): Observable<WatchFragmentResult<TFragmentData>> {\n    return this.cache.watchFragment<TFragmentData, TVariables>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<ApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as RefetchQueriesOptions<ApolloCache<TCacheShape>, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   * ```ts\n   * console.log(client.getMemoryInternals())\n   * ```\n   * Logs output in the following JSON format:\n   * @example\n   * ```json\n   *{\n   *  limits:     {\n   *    parser: 1000,\n   *    canonicalStringify: 1000,\n   *    print: 2000,\n   *    'documentTransform.cache': 2000,\n   *    'queryManager.getDocumentInfo': 2000,\n   *    'PersistedQueryLink.persistedQueryHashes': 2000,\n   *    'fragmentRegistry.transform': 2000,\n   *    'fragmentRegistry.lookup': 1000,\n   *    'fragmentRegistry.findFragmentSpreads': 4000,\n   *    'cache.fragmentQueryDocuments': 1000,\n   *    'removeTypenameFromVariables.getVariableDefinitions': 2000,\n   *    'inMemoryCache.maybeBroadcastWatch': 5000,\n   *    'inMemoryCache.executeSelectionSet': 10000,\n   *    'inMemoryCache.executeSubSelectedArray': 5000\n   *  },\n   *  sizes: {\n   *    parser: 26,\n   *    canonicalStringify: 4,\n   *    print: 14,\n   *    addTypenameDocumentTransform: [\n   *      {\n   *        cache: 14,\n   *      },\n   *    ],\n   *    queryManager: {\n   *      getDocumentInfo: 14,\n   *      documentTransforms: [\n   *        {\n   *          cache: 14,\n   *        },\n   *        {\n   *          cache: 14,\n   *        },\n   *      ],\n   *    },\n   *    fragmentRegistry: {\n   *      findFragmentSpreads: 34,\n   *      lookup: 20,\n   *      transform: 14,\n   *    },\n   *    cache: {\n   *      fragmentQueryDocuments: 22,\n   *    },\n   *    inMemoryCache: {\n   *      executeSelectionSet: 4345,\n   *      executeSubSelectedArray: 1206,\n   *      maybeBroadcastWatch: 32,\n   *    },\n   *    links: [\n   *      {\n   *        PersistedQueryLink: {\n   *          persistedQueryHashes: 14,\n   *        },\n   *      },\n   *      {\n   *        removeTypenameFromVariables: {\n   *          getVariableDefinitions: 14,\n   *        },\n   *      },\n   *    ],\n   *  },\n   * }\n   *```\n   */\n  public getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n", "/* Core */\n\nexport type { ApolloClientOptions, DefaultOptions } from \"./ApolloClient.js\";\nexport { ApolloClient, mergeOptions } from \"./ApolloClient.js\";\nexport type {\n  FetchMoreOptions,\n  UpdateQueryOptions,\n} from \"./ObservableQuery.js\";\nexport { ObservableQuery } from \"./ObservableQuery.js\";\nexport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  FetchPolicy,\n  WatchQueryFetchPolicy,\n  MutationFetchPolicy,\n  RefetchWritePolicy,\n  ErrorPolicy,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n} from \"./watchQueryOptions.js\";\nexport { NetworkStatus, isNetworkRequestSettled } from \"./networkStatus.js\";\nexport * from \"./types.js\";\nexport type { Resolver, FragmentMatcher } from \"./LocalState.js\";\nexport { isApolloError, ApolloError } from \"../errors/index.js\";\n/* Cache */\n\nexport type {\n  // All the exports (types) from ../cache, minus cacheSlot,\n  // which we want to keep semi-private.\n  Transaction,\n  DataProxy,\n  InMemoryCacheConfig,\n  ReactiveVar,\n  TypePolicies,\n  TypePolicy,\n  FieldPolicy,\n  FieldReadFunction,\n  FieldMergeFunction,\n  FieldFunctionOptions,\n  PossibleTypesMap,\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/index.js\";\nexport {\n  Cache,\n  ApolloCache,\n  InMemoryCache,\n  MissingFieldError,\n  defaultDataIdFromObject,\n  makeVar,\n} from \"../cache/index.js\";\n\nexport * from \"../cache/inmemory/types.js\";\n\n/* Link */\n\nexport * from \"../link/core/index.js\";\nexport * from \"../link/http/index.js\";\nexport type { ServerError } from \"../link/utils/index.js\";\nexport {\n  fromError,\n  toPromise,\n  fromPromise,\n  throwServerError,\n} from \"../link/utils/index.js\";\n\n/* Utilities */\n\nexport type {\n  DocumentTransformCacheKey,\n  Observer,\n  ObservableSubscription,\n  Reference,\n  StoreObject,\n} from \"../utilities/index.js\";\nexport {\n  DocumentTransform,\n  Observable,\n  isReference,\n  makeReference,\n} from \"../utilities/index.js\";\n\n/* Supporting */\n\n// The verbosity of invariant.{log,warn,error} can be controlled globally\n// (for anyone using the same ts-invariant package) by passing \"log\",\n// \"warn\", \"error\", or \"silent\" to setVerbosity (\"log\" is the default).\n// Note that all invariant.* logging is hidden in production.\nimport { setVerbosity } from \"ts-invariant\";\nexport { setVerbosity as setLogVerbosity };\nsetVerbosity(__DEV__ ? \"log\" : \"silent\");\n\n// Note that importing `gql` by itself, then destructuring\n// additional properties separately before exporting, is intentional.\n// Due to the way the `graphql-tag` library is setup, certain bundlers\n// can't find the properties added to the exported `gql` function without\n// additional guidance (e.g. Rollup - see\n// https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module).\n// Instead of having people that are using bundlers with `@apollo/client` add\n// extra bundler config to help `graphql-tag` exports be found (which would be\n// awkward since they aren't importing `graphql-tag` themselves), this\n// workaround of pulling the extra properties off the `gql` function,\n// then re-exporting them separately, helps keeps bundlers happy without any\n// additional config changes.\nexport {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n} from \"graphql-tag\";\n"],
  "mappings": "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",
  "names": ["ApolloLink", "err", "ApolloError", "print", "_a", "version", "_b", "_c", "parseError", "HttpLink", "NetworkStatus", "hasOwnProperty", "ObservableQuery", "_a", "info", "LocalState", "execute", "_a", "node", "QueryInfo", "diff", "hasOwnProperty", "QueryManager", "defaultOptions", "hasClientExports", "cache", "diff", "result", "variables", "sourcesWithInfo", "_a", "networkStatus", "data", "ApolloClient", "defaultOptions", "result"]
}
