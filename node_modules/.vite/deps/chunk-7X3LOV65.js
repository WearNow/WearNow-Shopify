import {
  __esm,
  __export
} from "./chunk-VRMXEQCD.js";

// node_modules/compare-versions/lib/esm/utils.js
var semver, validateAndParse, isWildcard, tryParse, forceType, compareStrings, compareSegments;
var init_utils = __esm({
  "node_modules/compare-versions/lib/esm/utils.js"() {
    semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
    validateAndParse = (version) => {
      if (typeof version !== "string") {
        throw new TypeError("Invalid argument expected string");
      }
      const match = version.match(semver);
      if (!match) {
        throw new Error(`Invalid argument not valid semver ('${version}' received)`);
      }
      match.shift();
      return match;
    };
    isWildcard = (s) => s === "*" || s === "x" || s === "X";
    tryParse = (v) => {
      const n = parseInt(v, 10);
      return isNaN(n) ? v : n;
    };
    forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
    compareStrings = (a, b) => {
      if (isWildcard(a) || isWildcard(b))
        return 0;
      const [ap, bp] = forceType(tryParse(a), tryParse(b));
      if (ap > bp)
        return 1;
      if (ap < bp)
        return -1;
      return 0;
    };
    compareSegments = (a, b) => {
      for (let i = 0; i < Math.max(a.length, b.length); i++) {
        const r = compareStrings(a[i] || "0", b[i] || "0");
        if (r !== 0)
          return r;
      }
      return 0;
    };
  }
});

// node_modules/compare-versions/lib/esm/compareVersions.js
var compareVersions;
var init_compareVersions = __esm({
  "node_modules/compare-versions/lib/esm/compareVersions.js"() {
    init_utils();
    compareVersions = (v1, v2) => {
      const n1 = validateAndParse(v1);
      const n2 = validateAndParse(v2);
      const p1 = n1.pop();
      const p2 = n2.pop();
      const r = compareSegments(n1, n2);
      if (r !== 0)
        return r;
      if (p1 && p2) {
        return compareSegments(p1.split("."), p2.split("."));
      } else if (p1 || p2) {
        return p1 ? -1 : 1;
      }
      return 0;
    };
  }
});

// node_modules/compare-versions/lib/esm/compare.js
var compare, operatorResMap, allowedOperators, assertValidOperator;
var init_compare = __esm({
  "node_modules/compare-versions/lib/esm/compare.js"() {
    init_compareVersions();
    compare = (v1, v2, operator) => {
      assertValidOperator(operator);
      const res = compareVersions(v1, v2);
      return operatorResMap[operator].includes(res);
    };
    operatorResMap = {
      ">": [1],
      ">=": [0, 1],
      "=": [0],
      "<=": [-1, 0],
      "<": [-1],
      "!=": [-1, 1]
    };
    allowedOperators = Object.keys(operatorResMap);
    assertValidOperator = (op) => {
      if (typeof op !== "string") {
        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);
      }
      if (allowedOperators.indexOf(op) === -1) {
        throw new Error(`Invalid operator, expected one of ${allowedOperators.join("|")}`);
      }
    };
  }
});

// node_modules/compare-versions/lib/esm/satisfies.js
var satisfies;
var init_satisfies = __esm({
  "node_modules/compare-versions/lib/esm/satisfies.js"() {
    init_compare();
    init_utils();
    satisfies = (version, range) => {
      range = range.replace(/([><=]+)\s+/g, "$1");
      if (range.includes("||")) {
        return range.split("||").some((r4) => satisfies(version, r4));
      } else if (range.includes(" - ")) {
        const [a, b] = range.split(" - ", 2);
        return satisfies(version, `>=${a} <=${b}`);
      } else if (range.includes(" ")) {
        return range.trim().replace(/\s{2,}/g, " ").split(" ").every((r4) => satisfies(version, r4));
      }
      const m = range.match(/^([<>=~^]+)/);
      const op = m ? m[1] : "=";
      if (op !== "^" && op !== "~")
        return compare(version, range, op);
      const [v1, v2, v3, , vp] = validateAndParse(version);
      const [r1, r2, r3, , rp] = validateAndParse(range);
      const v = [v1, v2, v3];
      const r = [r1, r2 !== null && r2 !== void 0 ? r2 : "x", r3 !== null && r3 !== void 0 ? r3 : "x"];
      if (rp) {
        if (!vp)
          return false;
        if (compareSegments(v, r) !== 0)
          return false;
        if (compareSegments(vp.split("."), rp.split(".")) === -1)
          return false;
      }
      const nonZero = r.findIndex((v4) => v4 !== "0") + 1;
      const i = op === "~" ? 2 : nonZero > 1 ? nonZero : 1;
      if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)
        return false;
      if (compareSegments(v.slice(i), r.slice(i)) === -1)
        return false;
      return true;
    };
  }
});

// node_modules/compare-versions/lib/esm/validate.js
var validate, validateStrict;
var init_validate = __esm({
  "node_modules/compare-versions/lib/esm/validate.js"() {
    init_utils();
    validate = (version) => typeof version === "string" && /^[v\d]/.test(version) && semver.test(version);
    validateStrict = (version) => typeof version === "string" && /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(version);
  }
});

// node_modules/compare-versions/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  compare: () => compare,
  compareVersions: () => compareVersions,
  satisfies: () => satisfies,
  validate: () => validate,
  validateStrict: () => validateStrict
});
var init_esm = __esm({
  "node_modules/compare-versions/lib/esm/index.js"() {
    init_compare();
    init_compareVersions();
    init_satisfies();
    init_validate();
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/constants.mjs
var CLIENT, MIN_RETRIES, MAX_RETRIES, GQL_API_ERROR, UNEXPECTED_CONTENT_TYPE_ERROR, NO_DATA_OR_ERRORS_ERROR, CONTENT_TYPES, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, DEFAULT_SDK_VARIANT, DEFAULT_CLIENT_VERSION, RETRY_WAIT_TIME, RETRIABLE_STATUS_CODES, DEFER_OPERATION_REGEX, NEWLINE_SEPARATOR, BOUNDARY_HEADER_REGEX, HEADER_SEPARATOR;
var init_constants = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/constants.mjs"() {
    CLIENT = "GraphQL Client";
    MIN_RETRIES = 0;
    MAX_RETRIES = 3;
    GQL_API_ERROR = "An error occurred while fetching from the API. Review 'graphQLErrors' for details.";
    UNEXPECTED_CONTENT_TYPE_ERROR = "Response returned unexpected Content-Type:";
    NO_DATA_OR_ERRORS_ERROR = "An unknown error has occurred. The API did not return a data object or any errors in its response.";
    CONTENT_TYPES = {
      json: "application/json",
      multipart: "multipart/mixed"
    };
    SDK_VARIANT_HEADER = "X-SDK-Variant";
    SDK_VERSION_HEADER = "X-SDK-Version";
    DEFAULT_SDK_VARIANT = "shopify-graphql-client";
    DEFAULT_CLIENT_VERSION = "0.10.4";
    RETRY_WAIT_TIME = 1e3;
    RETRIABLE_STATUS_CODES = [429, 503];
    DEFER_OPERATION_REGEX = /@(defer)\b/i;
    NEWLINE_SEPARATOR = "\r\n";
    BOUNDARY_HEADER_REGEX = /boundary="?([^=";]+)"?/i;
    HEADER_SEPARATOR = NEWLINE_SEPARATOR + NEWLINE_SEPARATOR;
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/utilities.mjs
function formatErrorMessage(message, client = CLIENT) {
  return message.startsWith(`${client}`) ? message : `${client}: ${message}`;
}
function getErrorMessage(error) {
  return error instanceof Error ? error.message : JSON.stringify(error);
}
function getErrorCause(error) {
  return error instanceof Error && error.cause ? error.cause : void 0;
}
function combineErrors(dataArray) {
  return dataArray.flatMap(({ errors }) => {
    return errors ?? [];
  });
}
function validateRetries({ client, retries }) {
  if (retries !== void 0 && (typeof retries !== "number" || retries < MIN_RETRIES || retries > MAX_RETRIES)) {
    throw new Error(`${client}: The provided "retries" value (${retries}) is invalid - it cannot be less than ${MIN_RETRIES} or greater than ${MAX_RETRIES}`);
  }
}
function getKeyValueIfValid(key, value) {
  return value && (typeof value !== "object" || Array.isArray(value) || typeof value === "object" && Object.keys(value).length > 0) ? { [key]: value } : {};
}
function buildDataObjectByPath(path, data) {
  if (path.length === 0) {
    return data;
  }
  const key = path.pop();
  const newData = {
    [key]: data
  };
  if (path.length === 0) {
    return newData;
  }
  return buildDataObjectByPath(path, newData);
}
function combineObjects(baseObject, newObject) {
  return Object.keys(newObject || {}).reduce((acc, key) => {
    if ((typeof newObject[key] === "object" || Array.isArray(newObject[key])) && baseObject[key]) {
      acc[key] = combineObjects(baseObject[key], newObject[key]);
      return acc;
    }
    acc[key] = newObject[key];
    return acc;
  }, Array.isArray(baseObject) ? [...baseObject] : { ...baseObject });
}
function buildCombinedDataObject([initialDatum, ...remainingData]) {
  return remainingData.reduce(combineObjects, { ...initialDatum });
}
var init_utilities = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/utilities.mjs"() {
    init_constants();
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/http-fetch.mjs
function generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES }) {
  const httpFetch = async (requestParams, count, maxRetries) => {
    const nextCount = count + 1;
    const maxTries = maxRetries + 1;
    let response;
    try {
      response = await customFetchApi(...requestParams);
      clientLogger({
        type: "HTTP-Response",
        content: {
          requestParams,
          response
        }
      });
      if (!response.ok && retriableCodes.includes(response.status) && nextCount <= maxTries) {
        throw new Error();
      }
      return response;
    } catch (error) {
      if (nextCount <= maxTries) {
        const retryAfter = response == null ? void 0 : response.headers.get("Retry-After");
        await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime);
        clientLogger({
          type: "HTTP-Retry",
          content: {
            requestParams,
            lastResponse: response,
            retryAttempt: count,
            maxRetries
          }
        });
        return httpFetch(requestParams, nextCount, maxRetries);
      }
      throw new Error(formatErrorMessage(`${maxRetries > 0 ? `Attempted maximum number of ${maxRetries} network retries. Last message - ` : ""}${getErrorMessage(error)}`, client));
    }
  };
  return httpFetch;
}
async function sleep(waitTime) {
  return new Promise((resolve) => setTimeout(resolve, waitTime));
}
var init_http_fetch = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/http-fetch.mjs"() {
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/graphql-client.mjs
function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger }) {
  validateRetries({ client: CLIENT, retries });
  const config = {
    headers,
    url,
    retries
  };
  const clientLogger = generateClientLogger(logger);
  const httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: RETRY_WAIT_TIME
  });
  const fetch2 = generateFetch(httpFetch, config);
  const request = generateRequest(fetch2);
  const requestStream = generateRequestStream(fetch2);
  return {
    config,
    fetch: fetch2,
    request,
    requestStream
  };
}
function generateClientLogger(logger) {
  return (logContent) => {
    if (logger) {
      logger(logContent);
    }
  };
}
async function processJSONResponse(response) {
  const { errors, data, extensions } = await response.json();
  return {
    ...getKeyValueIfValid("data", data),
    ...getKeyValueIfValid("extensions", extensions),
    ...errors || !data ? {
      errors: {
        networkStatusCode: response.status,
        message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),
        ...getKeyValueIfValid("graphQLErrors", errors),
        response
      }
    } : {}
  };
}
function generateFetch(httpFetch, { url, headers, retries }) {
  return async (operation, options = {}) => {
    const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries } = options;
    const body = JSON.stringify({
      query: operation,
      variables
    });
    validateRetries({ client: CLIENT, retries: overrideRetries });
    const flatHeaders = Object.entries({
      ...headers,
      ...overrideHeaders
    }).reduce((headers2, [key, value]) => {
      headers2[key] = Array.isArray(value) ? value.join(", ") : value.toString();
      return headers2;
    }, {});
    if (!flatHeaders[SDK_VARIANT_HEADER] && !flatHeaders[SDK_VERSION_HEADER]) {
      flatHeaders[SDK_VARIANT_HEADER] = DEFAULT_SDK_VARIANT;
      flatHeaders[SDK_VERSION_HEADER] = DEFAULT_CLIENT_VERSION;
    }
    const fetchParams = [
      overrideUrl ?? url,
      {
        method: "POST",
        headers: flatHeaders,
        body
      }
    ];
    return httpFetch(fetchParams, 1, overrideRetries ?? retries);
  };
}
function generateRequest(fetch2) {
  return async (...props) => {
    if (DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation will result in a streamable response - use requestStream() instead."));
    }
    try {
      const response = await fetch2(...props);
      const { status, statusText } = response;
      const contentType = response.headers.get("content-type") || "";
      if (!response.ok) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(statusText),
            response
          }
        };
      }
      if (!contentType.includes(CONTENT_TYPES.json)) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
            response
          }
        };
      }
      return processJSONResponse(response);
    } catch (error) {
      return {
        errors: {
          message: getErrorMessage(error)
        }
      };
    }
  };
}
async function* getStreamBodyIterator(response) {
  const decoder = new TextDecoder();
  if (response.body[Symbol.asyncIterator]) {
    for await (const chunk of response.body) {
      yield decoder.decode(chunk);
    }
  } else {
    const reader = response.body.getReader();
    let readResult;
    try {
      while (!(readResult = await reader.read()).done) {
        yield decoder.decode(readResult.value);
      }
    } finally {
      reader.cancel();
    }
  }
}
function readStreamChunk(streamBodyIterator, boundary) {
  return {
    async *[Symbol.asyncIterator]() {
      try {
        let buffer = "";
        for await (const textChunk of streamBodyIterator) {
          buffer += textChunk;
          if (buffer.indexOf(boundary) > -1) {
            const lastBoundaryIndex = buffer.lastIndexOf(boundary);
            const fullResponses = buffer.slice(0, lastBoundaryIndex);
            const chunkBodies = fullResponses.split(boundary).filter((chunk) => chunk.trim().length > 0).map((chunk) => {
              const body = chunk.slice(chunk.indexOf(HEADER_SEPARATOR) + HEADER_SEPARATOR.length).trim();
              return body;
            });
            if (chunkBodies.length > 0) {
              yield chunkBodies;
            }
            buffer = buffer.slice(lastBoundaryIndex + boundary.length);
            if (buffer.trim() === `--`) {
              buffer = "";
            }
          }
        }
      } catch (error) {
        throw new Error(`Error occured while processing stream payload - ${getErrorMessage(error)}`);
      }
    }
  };
}
function createJsonResponseAsyncIterator(response) {
  return {
    async *[Symbol.asyncIterator]() {
      const processedResponse = await processJSONResponse(response);
      yield {
        ...processedResponse,
        hasNext: false
      };
    }
  };
}
function getResponseDataFromChunkBodies(chunkBodies) {
  return chunkBodies.map((value) => {
    try {
      return JSON.parse(value);
    } catch (error) {
      throw new Error(`Error in parsing multipart response - ${getErrorMessage(error)}`);
    }
  }).map((payload) => {
    const { data, incremental, hasNext, extensions, errors } = payload;
    if (!incremental) {
      return {
        data: data || {},
        ...getKeyValueIfValid("errors", errors),
        ...getKeyValueIfValid("extensions", extensions),
        hasNext
      };
    }
    const incrementalArray = incremental.map(({ data: data2, path, errors: errors2 }) => {
      return {
        data: data2 && path ? buildDataObjectByPath(path, data2) : {},
        ...getKeyValueIfValid("errors", errors2)
      };
    });
    return {
      data: incrementalArray.length === 1 ? incrementalArray[0].data : buildCombinedDataObject([
        ...incrementalArray.map(({ data: data2 }) => data2)
      ]),
      ...getKeyValueIfValid("errors", combineErrors(incrementalArray)),
      hasNext
    };
  });
}
function validateResponseData(responseErrors, combinedData) {
  if (responseErrors.length > 0) {
    throw new Error(GQL_API_ERROR, {
      cause: {
        graphQLErrors: responseErrors
      }
    });
  }
  if (Object.keys(combinedData).length === 0) {
    throw new Error(NO_DATA_OR_ERRORS_ERROR);
  }
}
function createMultipartResponseAsyncInterator(response, responseContentType) {
  var _a;
  const boundaryHeader = (responseContentType ?? "").match(BOUNDARY_HEADER_REGEX);
  const boundary = `--${boundaryHeader ? boundaryHeader[1] : "-"}`;
  if (!((_a = response.body) == null ? void 0 : _a.getReader) && !response.body[Symbol.asyncIterator]) {
    throw new Error("API multipart response did not return an iterable body", {
      cause: response
    });
  }
  const streamBodyIterator = getStreamBodyIterator(response);
  let combinedData = {};
  let responseExtensions;
  return {
    async *[Symbol.asyncIterator]() {
      var _a2;
      try {
        let streamHasNext = true;
        for await (const chunkBodies of readStreamChunk(streamBodyIterator, boundary)) {
          const responseData = getResponseDataFromChunkBodies(chunkBodies);
          responseExtensions = ((_a2 = responseData.find((datum) => datum.extensions)) == null ? void 0 : _a2.extensions) ?? responseExtensions;
          const responseErrors = combineErrors(responseData);
          combinedData = buildCombinedDataObject([
            combinedData,
            ...responseData.map(({ data }) => data)
          ]);
          streamHasNext = responseData.slice(-1)[0].hasNext;
          validateResponseData(responseErrors, combinedData);
          yield {
            ...getKeyValueIfValid("data", combinedData),
            ...getKeyValueIfValid("extensions", responseExtensions),
            hasNext: streamHasNext
          };
        }
        if (streamHasNext) {
          throw new Error(`Response stream terminated unexpectedly`);
        }
      } catch (error) {
        const cause = getErrorCause(error);
        yield {
          ...getKeyValueIfValid("data", combinedData),
          ...getKeyValueIfValid("extensions", responseExtensions),
          errors: {
            message: formatErrorMessage(getErrorMessage(error)),
            networkStatusCode: response.status,
            ...getKeyValueIfValid("graphQLErrors", cause == null ? void 0 : cause.graphQLErrors),
            response
          },
          hasNext: false
        };
      }
    }
  };
}
function generateRequestStream(fetch2) {
  return async (...props) => {
    if (!DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation does not result in a streamable response - use request() instead."));
    }
    try {
      const response = await fetch2(...props);
      const { statusText } = response;
      if (!response.ok) {
        throw new Error(statusText, { cause: response });
      }
      const responseContentType = response.headers.get("content-type") || "";
      switch (true) {
        case responseContentType.includes(CONTENT_TYPES.json):
          return createJsonResponseAsyncIterator(response);
        case responseContentType.includes(CONTENT_TYPES.multipart):
          return createMultipartResponseAsyncInterator(response, responseContentType);
        default:
          throw new Error(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${responseContentType}`, { cause: response });
      }
    } catch (error) {
      return {
        async *[Symbol.asyncIterator]() {
          const response = getErrorCause(error);
          yield {
            errors: {
              message: formatErrorMessage(getErrorMessage(error)),
              ...getKeyValueIfValid("networkStatusCode", response == null ? void 0 : response.status),
              ...getKeyValueIfValid("response", response)
            },
            hasNext: false
          };
        }
      };
    }
  };
}
var init_graphql_client = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/graphql-client.mjs"() {
    init_http_fetch();
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/graphql-client/dist/api-client-utilities/validations.mjs
function validateDomainAndGetStoreUrl({ client, storeDomain }) {
  try {
    if (!storeDomain || typeof storeDomain !== "string") {
      throw new Error();
    }
    const trimmedDomain = storeDomain.trim();
    const protocolUrl = trimmedDomain.match(/^https?:/) ? trimmedDomain : `https://${trimmedDomain}`;
    const url = new URL(protocolUrl);
    url.protocol = "https";
    return url.origin;
  } catch (_error) {
    throw new Error(`${client}: a valid store domain ("${storeDomain}") must be provided`);
  }
}
function validateApiVersion({ client, currentSupportedApiVersions, apiVersion, logger }) {
  const versionError = `${client}: the provided apiVersion ("${apiVersion}")`;
  const supportedVersion = `Currently supported API versions: ${currentSupportedApiVersions.join(", ")}`;
  if (!apiVersion || typeof apiVersion !== "string") {
    throw new Error(`${versionError} is invalid. ${supportedVersion}`);
  }
  const trimmedApiVersion = apiVersion.trim();
  if (!currentSupportedApiVersions.includes(trimmedApiVersion)) {
    if (logger) {
      logger({
        type: "Unsupported_Api_Version",
        content: {
          apiVersion,
          supportedApiVersions: currentSupportedApiVersions
        }
      });
    } else {
      console.warn(`${versionError} is likely deprecated or not supported. ${supportedVersion}`);
    }
  }
}
var init_validations = __esm({
  "node_modules/@shopify/graphql-client/dist/api-client-utilities/validations.mjs"() {
  }
});

// node_modules/@shopify/graphql-client/dist/api-client-utilities/api-versions.mjs
function getQuarterMonth(quarter) {
  const month = quarter * 3 - 2;
  return month === 10 ? month : `0${month}`;
}
function getPrevousVersion(year, quarter, nQuarter) {
  const versionQuarter = quarter - nQuarter;
  if (versionQuarter <= 0) {
    return `${year - 1}-${getQuarterMonth(versionQuarter + 4)}`;
  }
  return `${year}-${getQuarterMonth(versionQuarter)}`;
}
function getCurrentApiVersion() {
  const date = /* @__PURE__ */ new Date();
  const month = date.getUTCMonth();
  const year = date.getUTCFullYear();
  const quarter = Math.floor(month / 3 + 1);
  return {
    year,
    quarter,
    version: `${year}-${getQuarterMonth(quarter)}`
  };
}
function getCurrentSupportedApiVersions() {
  const { year, quarter, version: currentVersion } = getCurrentApiVersion();
  const nextVersion = quarter === 4 ? `${year + 1}-01` : `${year}-${getQuarterMonth(quarter + 1)}`;
  return [
    getPrevousVersion(year, quarter, 3),
    getPrevousVersion(year, quarter, 2),
    getPrevousVersion(year, quarter, 1),
    currentVersion,
    nextVersion,
    "unstable"
  ];
}
var init_api_versions = __esm({
  "node_modules/@shopify/graphql-client/dist/api-client-utilities/api-versions.mjs"() {
  }
});

// node_modules/@shopify/graphql-client/dist/api-client-utilities/utilities.mjs
function generateGetHeaders(config) {
  return (customHeaders) => {
    return { ...customHeaders ?? {}, ...config.headers };
  };
}
function generateGetGQLClientParams({ getHeaders, getApiUrl }) {
  return (operation, options) => {
    const props = [operation];
    if (options && Object.keys(options).length > 0) {
      const { variables, apiVersion: propApiVersion, headers, retries } = options;
      props.push({
        ...variables ? { variables } : {},
        ...headers ? { headers: getHeaders(headers) } : {},
        ...propApiVersion ? { url: getApiUrl(propApiVersion) } : {},
        ...retries ? { retries } : {}
      });
    }
    return props;
  };
}
var init_utilities2 = __esm({
  "node_modules/@shopify/graphql-client/dist/api-client-utilities/utilities.mjs"() {
  }
});

// node_modules/@shopify/graphql-client/dist/index.mjs
var init_dist = __esm({
  "node_modules/@shopify/graphql-client/dist/index.mjs"() {
    init_graphql_client();
    init_utilities();
    init_validations();
    init_api_versions();
    init_http_fetch();
    init_utilities2();
  }
});

// node_modules/@shopify/admin-api-client/dist/constants.mjs
var DEFAULT_CONTENT_TYPE, DEFAULT_CLIENT_VERSION2, ACCESS_TOKEN_HEADER, CLIENT2, RETRIABLE_STATUS_CODES2, DEFAULT_RETRY_WAIT_TIME;
var init_constants2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/constants.mjs"() {
    DEFAULT_CONTENT_TYPE = "application/json";
    DEFAULT_CLIENT_VERSION2 = "0.2.9";
    ACCESS_TOKEN_HEADER = "X-Shopify-Access-Token";
    CLIENT2 = "Admin API Client";
    RETRIABLE_STATUS_CODES2 = [429, 500, 503];
    DEFAULT_RETRY_WAIT_TIME = 1e3;
  }
});

// node_modules/@shopify/admin-api-client/dist/validations.mjs
function validateRequiredAccessToken(accessToken) {
  if (!accessToken) {
    throw new Error(`${CLIENT2}: an access token must be provided`);
  }
}
function validateServerSideUsage() {
  if (typeof window !== "undefined") {
    throw new Error(`${CLIENT2}: this client should not be used in the browser`);
  }
}
var init_validations2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/validations.mjs"() {
    init_constants2();
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql/client.mjs
function createAdminApiClient({ storeDomain, apiVersion, accessToken, userAgentPrefix, retries = 0, customFetchApi, logger }) {
  const currentSupportedApiVersions = getCurrentSupportedApiVersions();
  const storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT2,
    storeDomain
  });
  const baseApiVersionValidationParams = {
    client: CLIENT2,
    currentSupportedApiVersions,
    logger
  };
  validateServerSideUsage();
  validateApiVersion({
    client: CLIENT2,
    currentSupportedApiVersions,
    apiVersion,
    logger
  });
  validateRequiredAccessToken(accessToken);
  const apiUrlFormatter = generateApiUrlFormatter(storeUrl, apiVersion, baseApiVersionValidationParams);
  const config = {
    storeDomain: storeUrl,
    apiVersion,
    accessToken,
    headers: {
      "Content-Type": DEFAULT_CONTENT_TYPE,
      Accept: DEFAULT_CONTENT_TYPE,
      [ACCESS_TOKEN_HEADER]: accessToken,
      "User-Agent": `${userAgentPrefix ? `${userAgentPrefix} | ` : ""}${CLIENT2} v${DEFAULT_CLIENT_VERSION2}`
    },
    apiUrl: apiUrlFormatter(),
    userAgentPrefix
  };
  const graphqlClient = createGraphQLClient({
    headers: config.headers,
    url: config.apiUrl,
    retries,
    customFetchApi,
    logger
  });
  const getHeaders = generateGetHeaders(config);
  const getApiUrl = generateGetApiUrl(config, apiUrlFormatter);
  const getGQLClientParams = generateGetGQLClientParams({
    getHeaders,
    getApiUrl
  });
  const client = {
    config,
    getHeaders,
    getApiUrl,
    fetch: (...props) => {
      return graphqlClient.fetch(...getGQLClientParams(...props));
    },
    request: (...props) => {
      return graphqlClient.request(...getGQLClientParams(...props));
    }
  };
  return Object.freeze(client);
}
function generateApiUrlFormatter(storeUrl, defaultApiVersion, baseApiVersionValidationParams) {
  return (apiVersion) => {
    if (apiVersion) {
      validateApiVersion({
        ...baseApiVersionValidationParams,
        apiVersion
      });
    }
    const urlApiVersion = (apiVersion ?? defaultApiVersion).trim();
    return `${storeUrl}/admin/api/${urlApiVersion}/graphql.json`;
  };
}
function generateGetApiUrl(config, apiUrlFormatter) {
  return (propApiVersion) => {
    return propApiVersion ? apiUrlFormatter(propApiVersion) : config.apiUrl;
  };
}
var init_client = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql/client.mjs"() {
    init_dist();
    init_constants2();
    init_validations2();
  }
});

// node_modules/@shopify/admin-api-client/dist/rest/types.mjs
var Method;
var init_types = __esm({
  "node_modules/@shopify/admin-api-client/dist/rest/types.mjs"() {
    (function(Method2) {
      Method2["Get"] = "GET";
      Method2["Post"] = "POST";
      Method2["Put"] = "PUT";
      Method2["Delete"] = "DELETE";
    })(Method || (Method = {}));
  }
});

// node_modules/@shopify/admin-api-client/dist/rest/client.mjs
function createAdminRestApiClient({ storeDomain, apiVersion, accessToken, userAgentPrefix, logger, customFetchApi = fetch, retries: clientRetries = 0, scheme = "https", defaultRetryTime = DEFAULT_RETRY_WAIT_TIME, formatPaths = true }) {
  const currentSupportedApiVersions = getCurrentSupportedApiVersions();
  const storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT2,
    storeDomain
  }).replace("https://", `${scheme}://`);
  const baseApiVersionValidationParams = {
    client: CLIENT2,
    currentSupportedApiVersions,
    logger
  };
  validateServerSideUsage();
  validateApiVersion({
    client: CLIENT2,
    currentSupportedApiVersions,
    apiVersion,
    logger
  });
  validateRequiredAccessToken(accessToken);
  validateRetries({ client: CLIENT2, retries: clientRetries });
  const apiUrlFormatter = generateApiUrlFormatter2(storeUrl, apiVersion, baseApiVersionValidationParams, formatPaths);
  const clientLogger = generateClientLogger2(logger);
  const httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: defaultRetryTime,
    client: CLIENT2,
    retriableCodes: RETRIABLE_STATUS_CODES2
  });
  const request = async (path, { method, data, headers: requestHeadersObj, searchParams, retries = 0, apiVersion: apiVersion2 }) => {
    validateRetries({ client: CLIENT2, retries });
    const url = apiUrlFormatter(path, searchParams ?? {}, apiVersion2);
    const requestHeaders = normalizedHeaders(requestHeadersObj ?? {});
    const userAgent = [
      ...requestHeaders["user-agent"] ? [requestHeaders["user-agent"]] : [],
      ...userAgentPrefix ? [userAgentPrefix] : [],
      `${CLIENT2} v${DEFAULT_CLIENT_VERSION2}`
    ].join(" | ");
    const headers = normalizedHeaders({
      "Content-Type": DEFAULT_CONTENT_TYPE,
      ...requestHeaders,
      Accept: DEFAULT_CONTENT_TYPE,
      [ACCESS_TOKEN_HEADER]: accessToken,
      "User-Agent": userAgent
    });
    const body = data && typeof data !== "string" ? JSON.stringify(data) : data;
    return httpFetch([url, { method, headers, ...body ? { body } : void 0 }], 1, retries ?? clientRetries);
  };
  return {
    get: (path, options) => request(path, { method: Method.Get, ...options }),
    put: (path, options) => request(path, { method: Method.Put, ...options }),
    post: (path, options) => request(path, { method: Method.Post, ...options }),
    delete: (path, options) => request(path, { method: Method.Delete, ...options })
  };
}
function generateApiUrlFormatter2(storeUrl, defaultApiVersion, baseApiVersionValidationParams, formatPaths = true) {
  return (path, searchParams, apiVersion) => {
    if (apiVersion) {
      validateApiVersion({
        ...baseApiVersionValidationParams,
        apiVersion
      });
    }
    function convertValue(params2, key, value) {
      if (Array.isArray(value)) {
        value.forEach((arrayValue) => convertValue(params2, `${key}[]`, arrayValue));
        return;
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([objKey, objValue]) => convertValue(params2, `${key}[${objKey}]`, objValue));
        return;
      }
      params2.append(key, String(value));
    }
    const urlApiVersion = (apiVersion ?? defaultApiVersion).trim();
    let cleanPath = path.replace(/^\//, "");
    if (formatPaths) {
      if (!cleanPath.startsWith("admin")) {
        cleanPath = `admin/api/${urlApiVersion}/${cleanPath}`;
      }
      if (!cleanPath.endsWith(".json")) {
        cleanPath = `${cleanPath}.json`;
      }
    }
    const params = new URLSearchParams();
    if (searchParams) {
      for (const [key, value] of Object.entries(searchParams)) {
        convertValue(params, key, value);
      }
    }
    const queryString = params.toString() ? `?${params.toString()}` : "";
    return `${storeUrl}/${cleanPath}${queryString}`;
  };
}
function generateClientLogger2(logger) {
  return (logContent) => {
    if (logger) {
      logger(logContent);
    }
  };
}
function normalizedHeaders(headersObj) {
  const normalizedHeaders2 = {};
  for (const [key, value] of Object.entries(headersObj)) {
    normalizedHeaders2[key.toLowerCase()] = Array.isArray(value) ? value.join(", ") : String(value);
  }
  return normalizedHeaders2;
}
var init_client2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/rest/client.mjs"() {
    init_dist();
    init_validations2();
    init_constants2();
    init_types();
  }
});

// node_modules/@shopify/admin-api-client/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  createAdminApiClient: () => createAdminApiClient,
  createAdminRestApiClient: () => createAdminRestApiClient
});
var init_dist2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/index.mjs"() {
    init_client();
    init_client2();
  }
});

export {
  compare,
  esm_exports,
  init_esm,
  createGraphQLClient,
  validateDomainAndGetStoreUrl,
  validateApiVersion,
  getCurrentSupportedApiVersions,
  generateGetHeaders,
  generateGetGQLClientParams,
  init_dist,
  createAdminApiClient,
  createAdminRestApiClient,
  dist_exports,
  init_dist2
};
//# sourceMappingURL=chunk-7X3LOV65.js.map
