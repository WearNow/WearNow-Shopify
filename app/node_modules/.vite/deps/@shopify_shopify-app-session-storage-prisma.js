import {
  browser_exports,
  dist_exports as dist_exports2,
  init_browser,
  init_dist as init_dist2
} from "./chunk-CJ44ZI5E.js";
import {
  init_tslib_es6,
  require_client,
  require_common,
  require_crypto,
  require_error,
  require_http,
  require_logger,
  require_network,
  require_platform,
  require_runtime,
  require_types,
  require_types2,
  require_types3,
  require_version,
  tslib_es6_exports
} from "./chunk-YRWXHLZJ.js";
import {
  dist_exports,
  init_dist2 as init_dist
} from "./chunk-RGORJ4LA.js";
import {
  require_index_browser
} from "./chunk-RW2PBTTW.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-QGSYD46Z.js";

// node_modules/@shopify/shopify-api/rest/load-rest-resources.js
var require_load_rest_resources = __commonJS({
  "node_modules/@shopify/shopify-api/rest/load-rest-resources.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadRestResources = void 0;
    var logger_1 = require_logger();
    function loadRestResources({ resources, config, RestClient }) {
      const firstResource = Object.keys(resources)[0];
      if (config.apiVersion !== resources[firstResource].apiVersion) {
        (0, logger_1.logger)(config).warning(`Loading REST resources for API version ${resources[firstResource].apiVersion}, which doesn't match the default ${config.apiVersion}`);
      }
      return Object.fromEntries(Object.entries(resources).map(([name, resource]) => {
        class NewResource extends resource {
        }
        NewResource.setClassProperties({
          Client: RestClient,
          config
        });
        Object.entries(NewResource.hasOne).map(([_attribute, klass]) => {
          klass.setClassProperties({
            Client: RestClient,
            config
          });
        });
        Object.entries(NewResource.hasMany).map(([_attribute, klass]) => {
          klass.setClassProperties({
            Client: RestClient,
            config
          });
        });
        Reflect.defineProperty(NewResource, "name", {
          value: name
        });
        return [name, NewResource];
      }));
    }
    exports.loadRestResources = loadRestResources;
  }
});

// node_modules/@shopify/shopify-api/future/flags.js
var require_flags = __commonJS({
  "node_modules/@shopify/shopify-api/future/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logDisabledFutureFlags = void 0;
    function logDisabledFutureFlags(config, logger) {
      var _a;
      if (!config._logDisabledFutureFlags) {
        return;
      }
      const logFlag = (flag, message) => logger.info(`Future flag ${flag} is disabled.

  ${message}
`);
      if (!((_a = config.future) == null ? void 0 : _a.v10_lineItemBilling)) {
        logFlag("v10_lineItemBilling", "Enable this flag to use the new billing API, that supports multiple line items per plan.");
      }
    }
    exports.logDisabledFutureFlags = logDisabledFutureFlags;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/scopes/index.js
var require_scopes = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/scopes/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthScopes = void 0;
    var AuthScopes = class _AuthScopes {
      constructor(scopes) {
        let scopesArray = [];
        if (typeof scopes === "string") {
          scopesArray = scopes.split(new RegExp(`${_AuthScopes.SCOPE_DELIMITER}\\s*`));
        } else if (Array.isArray(scopes)) {
          scopesArray = scopes;
        } else if (scopes) {
          scopesArray = Array.from(scopes.expandedScopes);
        }
        scopesArray = scopesArray.map((scope) => scope.trim()).filter((scope) => scope.length);
        const impliedScopes = this.getImpliedScopes(scopesArray);
        const scopeSet = new Set(scopesArray);
        const impliedSet = new Set(impliedScopes);
        this.compressedScopes = new Set([...scopeSet].filter((x) => !impliedSet.has(x)));
        this.expandedScopes = /* @__PURE__ */ new Set([...scopeSet, ...impliedSet]);
      }
      /**
       * Checks whether the current set of scopes includes the given one.
       */
      has(scope) {
        let other;
        if (scope instanceof _AuthScopes) {
          other = scope;
        } else {
          other = new _AuthScopes(scope);
        }
        return other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0;
      }
      /**
       * Checks whether the current set of scopes equals the given one.
       */
      equals(otherScopes) {
        let other;
        if (otherScopes instanceof _AuthScopes) {
          other = otherScopes;
        } else {
          other = new _AuthScopes(otherScopes);
        }
        return this.compressedScopes.size === other.compressedScopes.size && this.toArray().filter((x) => !other.has(x)).length === 0;
      }
      /**
       * Returns a comma-separated string with the current set of scopes.
       */
      toString() {
        return this.toArray().join(_AuthScopes.SCOPE_DELIMITER);
      }
      /**
       * Returns an array with the current set of scopes.
       */
      toArray() {
        return [...this.compressedScopes];
      }
      getImpliedScopes(scopesArray) {
        return scopesArray.reduce((array, current) => {
          const matches = current.match(/^(unauthenticated_)?write_(.*)$/);
          if (matches) {
            array.push(`${matches[1] ? matches[1] : ""}read_${matches[2]}`);
          }
          return array;
        }, []);
      }
    };
    exports.AuthScopes = AuthScopes;
    AuthScopes.SCOPE_DELIMITER = ",";
  }
});

// node_modules/@shopify/shopify-api/lib/config.js
var require_config = __commonJS({
  "node_modules/@shopify/shopify-api/lib/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateConfig = void 0;
    var error_1 = require_error();
    var types_1 = require_types();
    var scopes_1 = require_scopes();
    var logger_1 = require_logger();
    function validateConfig(params) {
      var _a;
      const config = {
        apiKey: "",
        apiSecretKey: "",
        scopes: new scopes_1.AuthScopes([]),
        hostName: "",
        hostScheme: "https",
        apiVersion: types_1.LATEST_API_VERSION,
        isEmbeddedApp: true,
        isCustomStoreApp: false,
        logger: {
          log: defaultLogFunction,
          level: types_1.LogSeverity.Info,
          httpRequests: false,
          timestamps: false
        },
        future: {},
        _logDisabledFutureFlags: true
      };
      const mandatory = ["apiSecretKey", "hostName"];
      if (!("isCustomStoreApp" in params) || !params.isCustomStoreApp) {
        mandatory.push("apiKey");
        mandatory.push("scopes");
      }
      if ("isCustomStoreApp" in params && params.isCustomStoreApp) {
        if (!("adminApiAccessToken" in params) || ((_a = params.adminApiAccessToken) == null ? void 0 : _a.length) === 0) {
          mandatory.push("adminApiAccessToken");
        }
      }
      const missing = [];
      mandatory.forEach((key) => {
        if (!notEmpty(params[key])) {
          missing.push(key);
        }
      });
      if (missing.length) {
        throw new error_1.ShopifyError(`Cannot initialize Shopify API Library. Missing values for: ${missing.join(", ")}`);
      }
      const { hostScheme, isCustomStoreApp, adminApiAccessToken, userAgentPrefix, logger, privateAppStorefrontAccessToken, customShopDomains, billing, ...mandatoryParams } = params;
      Object.assign(config, mandatoryParams, {
        hostName: params.hostName.replace(/\/$/, ""),
        scopes: params.scopes instanceof scopes_1.AuthScopes ? params.scopes : new scopes_1.AuthScopes(params.scopes),
        hostScheme: hostScheme ?? config.hostScheme,
        isCustomStoreApp: isCustomStoreApp ?? config.isCustomStoreApp,
        adminApiAccessToken: adminApiAccessToken ?? config.adminApiAccessToken,
        userAgentPrefix: userAgentPrefix ?? config.userAgentPrefix,
        logger: { ...config.logger, ...logger || {} },
        privateAppStorefrontAccessToken: privateAppStorefrontAccessToken ?? config.privateAppStorefrontAccessToken,
        customShopDomains: customShopDomains ?? config.customShopDomains,
        billing: billing ?? config.billing
      });
      if (config.isCustomStoreApp && params.adminApiAccessToken === params.apiSecretKey) {
        (0, logger_1.logger)(config).warning("adminApiAccessToken is set to the same value as apiSecretKey. adminApiAccessToken should be set to the Admin API access token for custom store apps; apiSecretKey should be set to the custom store app's API secret key.");
      }
      return config;
    }
    exports.validateConfig = validateConfig;
    function notEmpty(value) {
      if (value == null) {
        return false;
      }
      return typeof value === "string" || Array.isArray(value) ? value.length > 0 : true;
    }
    function defaultLogFunction(severity, message) {
      switch (severity) {
        case types_1.LogSeverity.Debug:
          console.debug(message);
          break;
        case types_1.LogSeverity.Info:
          console.log(message);
          break;
        case types_1.LogSeverity.Warning:
          console.warn(message);
          break;
        case types_1.LogSeverity.Error:
          console.error(message);
          break;
      }
    }
  }
});

// node_modules/@shopify/shopify-api/lib/clients/admin/rest/client.js
var require_client2 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/admin/rest/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.restClientClass = exports.RestClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var admin_api_client_1 = (init_dist(), __toCommonJS(dist_exports));
    var network_1 = require_network();
    var common_1 = require_common();
    var runtime_1 = require_runtime();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var logger_1 = require_logger();
    var RestClient = class _RestClient {
      constructor({ session, apiVersion }) {
        this.loggedDeprecations = {};
        const config = this.restClass().config;
        if (!config.isCustomStoreApp && !session.accessToken) {
          throw new ShopifyErrors.MissingRequiredArgument("Missing access token when creating REST client");
        }
        if (apiVersion) {
          const message = apiVersion === config.apiVersion ? `REST client has a redundant API version override to the default ${apiVersion}` : `REST client overriding default API version ${config.apiVersion} with ${apiVersion}`;
          (0, logger_1.logger)(config).debug(message);
        }
        const customStoreAppAccessToken = config.adminApiAccessToken ?? config.apiSecretKey;
        this.session = session;
        this.apiVersion = apiVersion ?? config.apiVersion;
        this.client = (0, admin_api_client_1.createAdminRestApiClient)({
          scheme: config.hostScheme,
          storeDomain: session.shop,
          apiVersion: apiVersion ?? config.apiVersion,
          accessToken: config.isCustomStoreApp ? customStoreAppAccessToken : session.accessToken,
          customFetchApi: runtime_1.abstractFetch,
          logger: (0, common_1.clientLoggerFactory)(config),
          userAgentPrefix: (0, common_1.getUserAgent)(config),
          defaultRetryTime: this.restClass().RETRY_WAIT_TIME,
          formatPaths: this.restClass().formatPaths
        });
      }
      /**
       * Performs a GET request on the given path.
       */
      async get(params) {
        return this.request({ method: network_1.Method.Get, ...params });
      }
      /**
       * Performs a POST request on the given path.
       */
      async post(params) {
        return this.request({ method: network_1.Method.Post, ...params });
      }
      /**
       * Performs a PUT request on the given path.
       */
      async put(params) {
        return this.request({ method: network_1.Method.Put, ...params });
      }
      /**
       * Performs a DELETE request on the given path.
       */
      async delete(params) {
        return this.request({ method: network_1.Method.Delete, ...params });
      }
      async request(params) {
        var _a, _b;
        const requestParams = {
          headers: {
            ...params.extraHeaders,
            ...params.type ? { "Content-Type": params.type.toString() } : {}
          },
          retries: params.tries ? params.tries - 1 : void 0,
          searchParams: params.query
        };
        let response;
        switch (params.method) {
          case network_1.Method.Get:
            response = await this.client.get(params.path, requestParams);
            break;
          case network_1.Method.Put:
            response = await this.client.put(params.path, {
              ...requestParams,
              data: params.data
            });
            break;
          case network_1.Method.Post:
            response = await this.client.post(params.path, {
              ...requestParams,
              data: params.data
            });
            break;
          case network_1.Method.Delete:
            response = await this.client.delete(params.path, requestParams);
            break;
          default:
            throw new ShopifyErrors.InvalidRequestError(`Unsupported request method '${params.method}'`);
        }
        const body = await response.json();
        const responseHeaders = (0, runtime_1.canonicalizeHeaders)(Object.fromEntries(response.headers.entries()));
        if (!response.ok) {
          (0, common_1.throwFailedRequest)(body, (params.tries ?? 1) > 1, response);
        }
        const requestReturn = {
          body,
          headers: responseHeaders
        };
        await this.logDeprecations({
          method: params.method,
          url: params.path,
          headers: requestParams.headers,
          body: params.data ? JSON.stringify(params.data) : void 0
        }, requestReturn);
        const link = response.headers.get("Link");
        if (link !== void 0) {
          const pageInfo = {
            limit: ((_a = params.query) == null ? void 0 : _a.limit) ? (_b = params.query) == null ? void 0 : _b.limit.toString() : _RestClient.DEFAULT_LIMIT
          };
          if (link) {
            const links = link.split(", ");
            for (const link2 of links) {
              const parsedLink = link2.match(_RestClient.LINK_HEADER_REGEXP);
              if (!parsedLink) {
                continue;
              }
              const linkRel = parsedLink[2];
              const linkUrl = new URL(parsedLink[1]);
              const linkFields = linkUrl.searchParams.get("fields");
              const linkPageToken = linkUrl.searchParams.get("page_info");
              if (!pageInfo.fields && linkFields) {
                pageInfo.fields = linkFields.split(",");
              }
              if (linkPageToken) {
                switch (linkRel) {
                  case "previous":
                    pageInfo.previousPageUrl = parsedLink[1];
                    pageInfo.prevPage = this.buildRequestParams(parsedLink[1]);
                    break;
                  case "next":
                    pageInfo.nextPageUrl = parsedLink[1];
                    pageInfo.nextPage = this.buildRequestParams(parsedLink[1]);
                    break;
                }
              }
            }
          }
          requestReturn.pageInfo = pageInfo;
        }
        return requestReturn;
      }
      restClass() {
        return this.constructor;
      }
      buildRequestParams(newPageUrl) {
        const pattern = `^/admin/api/[^/]+/(.*).json$`;
        const url = new URL(newPageUrl);
        const path = url.pathname.replace(new RegExp(pattern), "$1");
        return {
          path,
          query: Object.fromEntries(url.searchParams.entries())
        };
      }
      async logDeprecations(request, response) {
        const config = this.restClass().config;
        const deprecationReason = (0, runtime_1.getHeader)(response.headers, "X-Shopify-API-Deprecated-Reason");
        if (deprecationReason) {
          const deprecation = {
            message: deprecationReason,
            path: request.url
          };
          if (request.body) {
            deprecation.body = `${request.body.substring(0, 100)}...`;
          }
          const depHash = await (0, runtime_1.createSHA256HMAC)(config.apiSecretKey, JSON.stringify(deprecation), runtime_1.HashFormat.Hex);
          if (!Object.keys(this.loggedDeprecations).includes(depHash) || Date.now() - this.loggedDeprecations[depHash] >= _RestClient.DEPRECATION_ALERT_DELAY) {
            this.loggedDeprecations[depHash] = Date.now();
            const stack = new Error().stack;
            const message = `API Deprecation Notice ${(/* @__PURE__ */ new Date()).toLocaleString()} : ${JSON.stringify(deprecation)}  -  Stack Trace: ${stack}`;
            await (0, logger_1.logger)(config).warning(message);
          }
        }
      }
    };
    exports.RestClient = RestClient;
    RestClient.LINK_HEADER_REGEXP = /<([^<]+)>; rel="([^"]+)"/;
    RestClient.DEFAULT_LIMIT = "50";
    RestClient.RETRY_WAIT_TIME = 1e3;
    RestClient.DEPRECATION_ALERT_DELAY = 3e5;
    function restClientClass(params) {
      const { config, formatPaths } = params;
      class NewRestClient extends RestClient {
      }
      NewRestClient.config = config;
      NewRestClient.formatPaths = formatPaths === void 0 ? true : formatPaths;
      Reflect.defineProperty(NewRestClient, "name", {
        value: "RestClient"
      });
      return NewRestClient;
    }
    exports.restClientClass = restClientClass;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/admin/index.js
var require_admin = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/admin/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RestClient = exports.restClientClass = exports.GraphqlClient = exports.graphqlClientClass = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports, "graphqlClientClass", { enumerable: true, get: function() {
      return client_1.graphqlClientClass;
    } });
    Object.defineProperty(exports, "GraphqlClient", { enumerable: true, get: function() {
      return client_1.GraphqlClient;
    } });
    var client_2 = require_client2();
    Object.defineProperty(exports, "restClientClass", { enumerable: true, get: function() {
      return client_2.restClientClass;
    } });
    Object.defineProperty(exports, "RestClient", { enumerable: true, get: function() {
      return client_2.RestClient;
    } });
  }
});

// node_modules/@shopify/shopify-api/lib/clients/storefront/client.js
var require_client3 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/storefront/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storefrontClientClass = exports.StorefrontClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var storefront_api_client_1 = (init_dist2(), __toCommonJS(dist_exports2));
    var logger_1 = require_logger();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var error_1 = require_error();
    var runtime_1 = require_runtime();
    var common_1 = require_common();
    var StorefrontClient = class {
      constructor(params) {
        const config = this.storefrontClass().config;
        if (!config.isCustomStoreApp && !params.session.accessToken) {
          throw new ShopifyErrors.MissingRequiredArgument("Missing access token when creating GraphQL client");
        }
        if (params.apiVersion) {
          const message = params.apiVersion === config.apiVersion ? `Storefront client has a redundant API version override to the default ${params.apiVersion}` : `Storefront client overriding default API version ${config.apiVersion} with ${params.apiVersion}`;
          (0, logger_1.logger)(config).debug(message);
        }
        let accessToken;
        if (config.isCustomStoreApp) {
          accessToken = config.privateAppStorefrontAccessToken;
          if (!accessToken) {
            throw new error_1.MissingRequiredArgument("Custom store apps must set the privateAppStorefrontAccessToken property to call the Storefront API.");
          }
        } else {
          accessToken = params.session.accessToken;
          if (!accessToken) {
            throw new error_1.MissingRequiredArgument("Session missing access token.");
          }
        }
        this.session = params.session;
        this.apiVersion = params.apiVersion;
        this.client = (0, storefront_api_client_1.createStorefrontApiClient)({
          privateAccessToken: accessToken,
          apiVersion: this.apiVersion ?? config.apiVersion,
          storeDomain: this.session.shop,
          customFetchApi: runtime_1.abstractFetch,
          logger: (0, common_1.clientLoggerFactory)(config),
          clientName: (0, common_1.getUserAgent)(config)
        });
      }
      async query(params) {
        (0, logger_1.logger)(this.storefrontClass().config).deprecated("10.0.0", "The query method is deprecated, and was replaced with the request method.\nSee the migration guide: https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/migrating-to-v9.md#using-the-new-clients.");
        if (typeof params.data === "string" && params.data.length === 0 || Object.entries(params.data).length === 0) {
          throw new ShopifyErrors.MissingRequiredArgument("Query missing.");
        }
        let operation;
        let variables;
        if (typeof params.data === "string") {
          operation = params.data;
        } else {
          operation = params.data.query;
          variables = params.data.variables;
        }
        const headers = Object.fromEntries(Object.entries((params == null ? void 0 : params.extraHeaders) ?? {}).map(([key, value]) => [
          key,
          Array.isArray(value) ? value.join(", ") : value.toString()
        ]));
        const response = await this.request(operation, {
          headers,
          retries: params.tries ? params.tries - 1 : void 0,
          variables
        });
        return { body: response, headers: {} };
      }
      async request(operation, options) {
        const response = await this.client.request(operation, {
          apiVersion: this.apiVersion || this.storefrontClass().config.apiVersion,
          ...options
        });
        if (response.errors) {
          const fetchResponse = response.errors.response;
          (0, common_1.throwFailedRequest)(response, ((options == null ? void 0 : options.retries) ?? 0) > 0, fetchResponse);
        }
        return response;
      }
      storefrontClass() {
        return this.constructor;
      }
    };
    exports.StorefrontClient = StorefrontClient;
    function storefrontClientClass(params) {
      const { config } = params;
      class NewStorefrontClient extends StorefrontClient {
      }
      NewStorefrontClient.config = config;
      Reflect.defineProperty(NewStorefrontClient, "name", {
        value: "StorefrontClient"
      });
      return NewStorefrontClient;
    }
    exports.storefrontClientClass = storefrontClientClass;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/storefront/index.js
var require_storefront = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/storefront/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storefrontClientClass = exports.StorefrontClient = void 0;
    var client_1 = require_client3();
    Object.defineProperty(exports, "StorefrontClient", { enumerable: true, get: function() {
      return client_1.StorefrontClient;
    } });
    Object.defineProperty(exports, "storefrontClientClass", { enumerable: true, get: function() {
      return client_1.storefrontClientClass;
    } });
  }
});

// node_modules/@shopify/shopify-api/lib/clients/graphql_proxy/graphql_proxy.js
var require_graphql_proxy = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/graphql_proxy/graphql_proxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.graphqlProxy = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var admin_1 = require_admin();
    function graphqlProxy(config) {
      return async ({ session, rawBody }) => {
        if (!session.accessToken) {
          throw new ShopifyErrors.InvalidSession("Cannot proxy query. Session not authenticated.");
        }
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        let query;
        let variables;
        if (typeof rawBody === "string") {
          query = rawBody;
        } else {
          query = rawBody.query;
          variables = rawBody.variables;
        }
        if (!query) {
          throw new ShopifyErrors.MissingRequiredArgument("Query missing.");
        }
        const response = await client.request(query, { variables });
        return { body: response, headers: {} };
      };
    }
    exports.graphqlProxy = graphqlProxy;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/index.js
var require_clients = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clientClasses = void 0;
    var admin_1 = require_admin();
    var storefront_1 = require_storefront();
    var graphql_proxy_1 = require_graphql_proxy();
    function clientClasses(config) {
      return {
        // We don't pass in the HttpClient because the RestClient inherits from it, and goes through the same setup process
        Rest: (0, admin_1.restClientClass)({ config }),
        Graphql: (0, admin_1.graphqlClientClass)({ config }),
        Storefront: (0, storefront_1.storefrontClientClass)({ config }),
        graphqlProxy: (0, graphql_proxy_1.graphqlProxy)(config)
      };
    }
    exports.clientClasses = clientClasses;
  }
});

// node_modules/isbot/index.js
var require_isbot = __commonJS({
  "node_modules/isbot/index.js"(exports, module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      createIsbot: () => createIsbot,
      createIsbotFromList: () => createIsbotFromList,
      getPattern: () => getPattern,
      isbot: () => isbot,
      isbotMatch: () => isbotMatch,
      isbotMatches: () => isbotMatches,
      isbotNaive: () => isbotNaive,
      isbotPattern: () => isbotPattern,
      isbotPatterns: () => isbotPatterns,
      list: () => list
    });
    module.exports = __toCommonJS2(src_exports);
    var patterns_default = [
      " daum[ /]",
      " deusu/",
      " yadirectfetcher",
      "(?:^|[^g])news",
      "(?<! (?:channel/|google/))google(?!(app|/google| pixel))",
      "(?<! cu)bot(?:[^\\w]|_|$)",
      "(?<!(?: ya| yandex|^job|inapp;) ?)search",
      "(?<!(?:lib))http",
      "(?<![hg]m)score",
      "(?<!android|ios)@",
      "\\(\\)",
      "\\.com",
      "^12345",
      "^<",
      "^[\\w \\.\\-\\(?:\\):]+(?:/v?\\d+(?:\\.\\d+)?(?:\\.\\d{1,10})*?)?(?:,|$)",
      "^[^ ]{50,}$",
      "^\\w+/[\\w\\(\\)]*$",
      "^active",
      "^ad muncher",
      "^amaya",
      "^avsdevicesdk/",
      "^biglotron",
      "^bot",
      "^bw/",
      "^clamav[ /]",
      "^client/",
      "^cobweb/",
      "^custom",
      "^ddg[_-]android",
      "^discourse",
      "^dispatch/\\d",
      "^downcast/",
      "^duckduckgo",
      "^facebook",
      "^getright/",
      "^gozilla/",
      "^hobbit",
      "^hotzonu",
      "^hwcdn/",
      "^jeode/",
      "^jetty/",
      "^jigsaw",
      "^microsoft bits",
      "^movabletype",
      "^mozilla/\\d\\.\\d \\(compatible;?\\)$",
      "^mozilla/\\d\\.\\d \\w*$",
      "^navermailapp",
      "^netsurf",
      "^offline explorer",
      "^postman",
      "^python",
      "^rank",
      "^read",
      "^reed",
      "^rest",
      "^serf",
      "^snapchat",
      "^space bison",
      "^svn",
      "^swcd ",
      "^taringa",
      "^thumbor/",
      "^track",
      "^valid",
      "^w3c",
      "^webbandit/",
      "^webcopier",
      "^wget",
      "^whatsapp",
      "^wordpress",
      "^xenu link sleuth",
      "^yahoo",
      "^yandex",
      "^zdm/\\d",
      "^zoom marketplace/",
      "^{{.*}}$",
      "analyzer",
      "archive",
      "ask jeeves/teoma",
      "bit\\.ly/",
      "bluecoat drtr",
      "browsex",
      "burpcollaborator",
      "capture",
      "catch",
      "check",
      "chrome-lighthouse",
      "chromeframe",
      "classifier",
      "cloud",
      "crawl",
      "cypress/",
      "dareboost",
      "datanyze",
      "dejaclick",
      "detect",
      "dmbrowser",
      "download",
      "evc-batch/",
      "feed",
      "firephp",
      "gomezagent",
      "headless",
      "httrack",
      "hubspot marketing grader",
      "hydra",
      "ibisbrowser",
      "images",
      "insight",
      "inspect",
      "iplabel",
      "ips-agent",
      "java(?!;)",
      "library",
      "mail\\.ru/",
      "manager",
      "measure",
      "neustar wpm",
      "node",
      "nutch",
      "offbyone",
      "optimize",
      "pageburst",
      "parser",
      "perl",
      "phantomjs",
      "pingdom",
      "powermarks",
      "preview",
      "proxy",
      "ptst[ /]\\d",
      "reputation",
      "resolver",
      "retriever",
      "rexx;",
      "rigor",
      "robot",
      "rss",
      "scan",
      "scrape",
      "server",
      "sogou",
      "sparkler/",
      "speedcurve",
      "spider",
      "splash",
      "statuscake",
      "supercleaner",
      "synapse",
      "synthetic",
      "tools",
      "torrent",
      "trace",
      "transcoder",
      "url",
      "virtuoso",
      "wappalyzer",
      "watch",
      "webglance",
      "webkit2png",
      "whatcms/",
      "zgrab"
    ];
    var fullPattern = " daum[ /]| deusu/| yadirectfetcher|(?:^|[^g])news|(?<! (?:channel/|google/))google(?!(app|/google| pixel))|(?<! cu)bot(?:[^\\w]|_|$)|(?<!(?: ya| yandex|^job|inapp;) ?)search|(?<!(?:lib))http|(?<![hg]m)score|(?<!android|ios)@|\\(\\)|\\.com|^12345|^<|^[\\w \\.\\-\\(?:\\):]+(?:/v?\\d+(?:\\.\\d+)?(?:\\.\\d{1,10})*?)?(?:,|$)|^[^ ]{50,}$|^\\w+/[\\w\\(\\)]*$|^active|^ad muncher|^amaya|^avsdevicesdk/|^biglotron|^bot|^bw/|^clamav[ /]|^client/|^cobweb/|^custom|^ddg[_-]android|^discourse|^dispatch/\\d|^downcast/|^duckduckgo|^facebook|^getright/|^gozilla/|^hobbit|^hotzonu|^hwcdn/|^jeode/|^jetty/|^jigsaw|^microsoft bits|^movabletype|^mozilla/\\d\\.\\d \\(compatible;?\\)$|^mozilla/\\d\\.\\d \\w*$|^navermailapp|^netsurf|^offline explorer|^postman|^python|^rank|^read|^reed|^rest|^serf|^snapchat|^space bison|^svn|^swcd |^taringa|^thumbor/|^track|^valid|^w3c|^webbandit/|^webcopier|^wget|^whatsapp|^wordpress|^xenu link sleuth|^yahoo|^yandex|^zdm/\\d|^zoom marketplace/|^{{.*}}$|analyzer|archive|ask jeeves/teoma|bit\\.ly/|bluecoat drtr|browsex|burpcollaborator|capture|catch|check|chrome-lighthouse|chromeframe|classifier|cloud|crawl|cypress/|dareboost|datanyze|dejaclick|detect|dmbrowser|download|evc-batch/|feed|firephp|gomezagent|headless|httrack|hubspot marketing grader|hydra|ibisbrowser|images|insight|inspect|iplabel|ips-agent|java(?!;)|library|mail\\.ru/|manager|measure|neustar wpm|node|nutch|offbyone|optimize|pageburst|parser|perl|phantomjs|pingdom|powermarks|preview|proxy|ptst[ /]\\d|reputation|resolver|retriever|rexx;|rigor|robot|rss|scan|scrape|server|sogou|sparkler/|speedcurve|spider|splash|statuscake|supercleaner|synapse|synthetic|tools|torrent|trace|transcoder|url|virtuoso|wappalyzer|watch|webglance|webkit2png|whatcms/|zgrab";
    var naivePattern = /bot|spider|crawl|http|lighthouse/i;
    var pattern;
    function getPattern() {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      try {
        pattern = new RegExp(fullPattern, "i");
      } catch (error) {
        pattern = naivePattern;
      }
      return pattern;
    }
    var list = patterns_default;
    var isbotNaive = (userAgent) => Boolean(userAgent) && naivePattern.test(userAgent);
    function isbot(userAgent) {
      return Boolean(userAgent) && getPattern().test(userAgent);
    }
    var createIsbot = (customPattern) => (userAgent) => Boolean(userAgent) && customPattern.test(userAgent);
    var createIsbotFromList = (list2) => {
      const pattern2 = new RegExp(list2.join("|"), "i");
      return (userAgent) => Boolean(userAgent) && pattern2.test(userAgent);
    };
    var isbotMatch = (userAgent) => {
      var _a, _b;
      return (_b = (_a = userAgent == null ? void 0 : userAgent.match(getPattern())) == null ? void 0 : _a[0]) != null ? _b : null;
    };
    var isbotMatches = (userAgent) => list.map((part) => {
      var _a;
      return (_a = userAgent == null ? void 0 : userAgent.match(new RegExp(part, "i"))) == null ? void 0 : _a[0];
    }).filter(Boolean);
    var isbotPattern = (userAgent) => {
      var _a;
      return userAgent ? (_a = list.find((pattern2) => new RegExp(pattern2, "i").test(userAgent))) != null ? _a : null : null;
    };
    var isbotPatterns = (userAgent) => userAgent ? list.filter((pattern2) => new RegExp(pattern2, "i").test(userAgent)) : [];
  }
});

// node_modules/@shopify/shopify-api/lib/utils/processed-query.js
var require_processed_query = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/processed-query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProcessedQuery = class _ProcessedQuery {
      static stringify(keyValuePairs) {
        if (!keyValuePairs || Object.keys(keyValuePairs).length === 0)
          return "";
        return new _ProcessedQuery().putAll(keyValuePairs).stringify();
      }
      constructor() {
        this.processedQuery = new URLSearchParams();
      }
      putAll(keyValuePairs) {
        Object.entries(keyValuePairs).forEach(([key, value]) => this.put(key, value));
        return this;
      }
      put(key, value) {
        if (Array.isArray(value)) {
          this.putArray(key, value);
        } else if ((value == null ? void 0 : value.constructor) === Object) {
          this.putObject(key, value);
        } else {
          this.putSimple(key, value);
        }
      }
      putArray(key, value) {
        value.forEach((arrayValue) => this.processedQuery.append(`${key}[]`, `${arrayValue}`));
      }
      putObject(key, value) {
        Object.entries(value).forEach(([entry, entryValue]) => {
          this.processedQuery.append(`${key}[${entry}]`, `${entryValue}`);
        });
      }
      putSimple(key, value) {
        this.processedQuery.append(key, `${value}`);
      }
      stringify(omitQuestionMark = false) {
        const queryString = this.processedQuery.toString();
        return omitQuestionMark ? queryString : `?${queryString}`;
      }
    };
    exports.default = ProcessedQuery;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/safe-compare.js
var require_safe_compare = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/safe-compare.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeCompare = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var safeCompare = (strA, strB) => {
      if (typeof strA === typeof strB) {
        const enc = new TextEncoder();
        const buffA = enc.encode(JSON.stringify(strA));
        const buffB = enc.encode(JSON.stringify(strB));
        if (buffA.length === buffB.length) {
          return timingSafeEqual(buffA, buffB);
        }
      } else {
        throw new ShopifyErrors.SafeCompareError(`Mismatched data types provided: ${typeof strA} and ${typeof strB}`);
      }
      return false;
    };
    exports.safeCompare = safeCompare;
    function timingSafeEqual(bufA, bufB) {
      const viewA = new Uint8Array(bufA);
      const viewB = new Uint8Array(bufB);
      let out = 0;
      for (let i = 0; i < viewA.length; i++) {
        out |= viewA[i] ^ viewB[i];
      }
      return out === 0;
    }
  }
});

// node_modules/@shopify/shopify-api/lib/utils/types.js
var require_types4 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidationErrorReason = exports.HmacValidationType = void 0;
    var HmacValidationType;
    (function(HmacValidationType2) {
      HmacValidationType2["Flow"] = "flow";
      HmacValidationType2["Webhook"] = "webhook";
      HmacValidationType2["FulfillmentService"] = "fulfillment_service";
    })(HmacValidationType || (exports.HmacValidationType = HmacValidationType = {}));
    exports.ValidationErrorReason = {
      MissingBody: "missing_body",
      InvalidHmac: "invalid_hmac",
      MissingHmac: "missing_hmac"
    };
  }
});

// node_modules/@shopify/shopify-api/lib/utils/hmac-validator.js
var require_hmac_validator = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/hmac-validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateHmacFromRequestFactory = exports.getCurrentTimeInSec = exports.validateHmacString = exports.validateHmac = exports.generateLocalHmac = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var logger_1 = require_logger();
    var types_1 = require_types();
    var http_1 = require_http();
    var crypto_1 = require_crypto();
    var types_2 = require_types2();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var safe_compare_1 = require_safe_compare();
    var processed_query_1 = tslib_1.__importDefault(require_processed_query());
    var types_3 = require_types4();
    var HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC = 90;
    function stringifyQueryForAdmin(query) {
      const processedQuery = new processed_query_1.default();
      Object.keys(query).sort((val1, val2) => val1.localeCompare(val2)).forEach((key) => processedQuery.put(key, query[key]));
      return processedQuery.stringify(true);
    }
    function stringifyQueryForAppProxy(query) {
      return Object.entries(query).sort(([val1], [val2]) => val1.localeCompare(val2)).reduce((acc, [key, value]) => {
        return `${acc}${key}=${Array.isArray(value) ? value.join(",") : value}`;
      }, "");
    }
    function generateLocalHmac(config) {
      return async (params, signator = "admin") => {
        const { hmac, signature, ...query } = params;
        const queryString = signator === "admin" ? stringifyQueryForAdmin(query) : stringifyQueryForAppProxy(query);
        return (0, crypto_1.createSHA256HMAC)(config.apiSecretKey, queryString, types_2.HashFormat.Hex);
      };
    }
    exports.generateLocalHmac = generateLocalHmac;
    function validateHmac(config) {
      return async (query, { signator } = { signator: "admin" }) => {
        if (signator === "admin" && !query.hmac) {
          throw new ShopifyErrors.InvalidHmacError("Query does not contain an HMAC value.");
        }
        if (signator === "appProxy" && !query.signature) {
          throw new ShopifyErrors.InvalidHmacError("Query does not contain a signature value.");
        }
        validateHmacTimestamp(query);
        const hmac = signator === "appProxy" ? query.signature : query.hmac;
        const localHmac = await generateLocalHmac(config)(query, signator);
        return (0, safe_compare_1.safeCompare)(hmac, localHmac);
      };
    }
    exports.validateHmac = validateHmac;
    async function validateHmacString(config, data, hmac, format) {
      const localHmac = await (0, crypto_1.createSHA256HMAC)(config.apiSecretKey, data, format);
      return (0, safe_compare_1.safeCompare)(hmac, localHmac);
    }
    exports.validateHmacString = validateHmacString;
    function getCurrentTimeInSec() {
      return Math.trunc(Date.now() / 1e3);
    }
    exports.getCurrentTimeInSec = getCurrentTimeInSec;
    function validateHmacFromRequestFactory(config) {
      return async function validateHmacFromRequest({ type, rawBody, ...adapterArgs }) {
        const request = await (0, http_1.abstractConvertRequest)(adapterArgs);
        if (!rawBody.length) {
          return fail(types_3.ValidationErrorReason.MissingBody, type, config);
        }
        const hmac = (0, http_1.getHeader)(request.headers, types_1.ShopifyHeader.Hmac);
        if (!hmac) {
          return fail(types_3.ValidationErrorReason.MissingHmac, type, config);
        }
        const validHmac = await validateHmacString(config, rawBody, hmac, types_2.HashFormat.Base64);
        if (!validHmac) {
          return fail(types_3.ValidationErrorReason.InvalidHmac, type, config);
        }
        return succeed(type, config);
      };
    }
    exports.validateHmacFromRequestFactory = validateHmacFromRequestFactory;
    function validateHmacTimestamp(query) {
      if (Math.abs(getCurrentTimeInSec() - Number(query.timestamp)) > HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC) {
        throw new ShopifyErrors.InvalidHmacError("HMAC timestamp is outside of the tolerance range");
      }
    }
    async function fail(reason, type, config) {
      const log = (0, logger_1.logger)(config);
      await log.debug(`${type} request is not valid`, { reason });
      return {
        valid: false,
        reason
      };
    }
    async function succeed(type, config) {
      const log = (0, logger_1.logger)(config);
      await log.debug(`${type} request is valid`);
      return {
        valid: true
      };
    }
  }
});

// node_modules/@shopify/shopify-api/lib/auth/decode-host.js
var require_decode_host = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/decode-host.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHost = void 0;
    function decodeHost(host) {
      return atob(host);
    }
    exports.decodeHost = decodeHost;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/shop-admin-url-helper.js
var require_shop_admin_url_helper = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/shop-admin-url-helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.legacyUrlToShopAdminUrl = exports.shopAdminUrlToLegacyUrl = void 0;
    function shopAdminUrlToLegacyUrl(shopAdminUrl) {
      const shopUrl = removeProtocol(shopAdminUrl);
      const isShopAdminUrl = shopUrl.split(".")[0] === "admin";
      if (!isShopAdminUrl) {
        return null;
      }
      const regex = new RegExp(`admin\\..+/store/([^/]+)`);
      const matches = shopUrl.match(regex);
      if (matches && matches.length === 2) {
        const shopName = matches[1];
        const isSpinUrl = shopUrl.includes("spin.dev/store/");
        if (isSpinUrl) {
          return spinAdminUrlToLegacyUrl(shopUrl);
        } else {
          return `${shopName}.myshopify.com`;
        }
      } else {
        return null;
      }
    }
    exports.shopAdminUrlToLegacyUrl = shopAdminUrlToLegacyUrl;
    function legacyUrlToShopAdminUrl(legacyAdminUrl) {
      const shopUrl = removeProtocol(legacyAdminUrl);
      const regex = new RegExp(`(.+)\\.myshopify\\.com$`);
      const matches = shopUrl.match(regex);
      if (matches && matches.length === 2) {
        const shopName = matches[1];
        return `admin.shopify.com/store/${shopName}`;
      } else {
        const isSpinUrl = shopUrl.endsWith("spin.dev");
        if (isSpinUrl) {
          return spinLegacyUrlToAdminUrl(shopUrl);
        } else {
          return null;
        }
      }
    }
    exports.legacyUrlToShopAdminUrl = legacyUrlToShopAdminUrl;
    function spinAdminUrlToLegacyUrl(shopAdminUrl) {
      const spinRegex = new RegExp(`admin\\.web\\.(.+\\.spin\\.dev)/store/(.+)`);
      const spinMatches = shopAdminUrl.match(spinRegex);
      if (spinMatches && spinMatches.length === 3) {
        const spinUrl = spinMatches[1];
        const shopName = spinMatches[2];
        return `${shopName}.shopify.${spinUrl}`;
      } else {
        return null;
      }
    }
    function spinLegacyUrlToAdminUrl(legacyAdminUrl) {
      const spinRegex = new RegExp(`(.+)\\.shopify\\.(.+\\.spin\\.dev)`);
      const spinMatches = legacyAdminUrl.match(spinRegex);
      if (spinMatches && spinMatches.length === 3) {
        const shopName = spinMatches[1];
        const spinUrl = spinMatches[2];
        return `admin.web.${spinUrl}/store/${shopName}`;
      } else {
        return null;
      }
    }
    function removeProtocol(url) {
      return url.replace(/^https?:\/\//, "").replace(/\/$/, "");
    }
  }
});

// node_modules/@shopify/shopify-api/lib/utils/shop-validator.js
var require_shop_validator = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/shop-validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeHost = exports.sanitizeShop = void 0;
    var error_1 = require_error();
    var decode_host_1 = require_decode_host();
    var shop_admin_url_helper_1 = require_shop_admin_url_helper();
    function sanitizeShop(config) {
      return (shop, throwOnInvalid = false) => {
        let shopUrl = shop;
        const domainsRegex = ["myshopify\\.com", "shopify\\.com", "myshopify\\.io"];
        if (config.customShopDomains) {
          domainsRegex.push(...config.customShopDomains.map((regex) => typeof regex === "string" ? regex : regex.source));
        }
        const shopUrlRegex = new RegExp(`^[a-zA-Z0-9][a-zA-Z0-9-_]*\\.(${domainsRegex.join("|")})[/]*$`);
        const shopAdminRegex = new RegExp(`^admin\\.(${domainsRegex.join("|")})/store/([a-zA-Z0-9][a-zA-Z0-9-_]*)$`);
        const isShopAdminUrl = shopAdminRegex.test(shopUrl);
        if (isShopAdminUrl) {
          shopUrl = (0, shop_admin_url_helper_1.shopAdminUrlToLegacyUrl)(shopUrl) || "";
        }
        const sanitizedShop = shopUrlRegex.test(shopUrl) ? shopUrl : null;
        if (!sanitizedShop && throwOnInvalid) {
          throw new error_1.InvalidShopError("Received invalid shop argument");
        }
        return sanitizedShop;
      };
    }
    exports.sanitizeShop = sanitizeShop;
    function sanitizeHost() {
      return (host, throwOnInvalid = false) => {
        const base64regex = /^[0-9a-zA-Z+/]+={0,2}$/;
        let sanitizedHost = base64regex.test(host) ? host : null;
        if (sanitizedHost) {
          const { hostname } = new URL(`https://${(0, decode_host_1.decodeHost)(sanitizedHost)}`);
          const originsRegex = [
            "myshopify\\.com",
            "shopify\\.com",
            "myshopify\\.io",
            "spin\\.dev"
          ];
          const hostRegex = new RegExp(`\\.(${originsRegex.join("|")})$`);
          if (!hostRegex.test(hostname)) {
            sanitizedHost = null;
          }
        }
        if (!sanitizedHost && throwOnInvalid) {
          throw new error_1.InvalidHostError("Received invalid host argument");
        }
        return sanitizedHost;
      };
    }
    exports.sanitizeHost = sanitizeHost;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/fetch-request.js
var require_fetch_request = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/fetch-request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fetchRequestFactory = void 0;
    var logger_1 = require_logger();
    var types_1 = require_types();
    var runtime_1 = require_runtime();
    function fetchRequestFactory(config) {
      return async function fetchRequest(url, options) {
        const log = (0, logger_1.logger)(config);
        const doLog = config.logger.httpRequests && config.logger.level === types_1.LogSeverity.Debug;
        if (doLog) {
          log.debug("Making HTTP request", {
            method: (options == null ? void 0 : options.method) || "GET",
            url,
            ...(options == null ? void 0 : options.body) && { body: options == null ? void 0 : options.body }
          });
        }
        const response = await (0, runtime_1.abstractFetch)(url, options);
        if (doLog) {
          log.debug("HTTP request completed", {
            method: (options == null ? void 0 : options.method) || "GET",
            url,
            status: response.status
          });
        }
        return response;
      };
    }
    exports.fetchRequestFactory = fetchRequestFactory;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/types.js
var require_types5 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STATE_COOKIE_NAME = exports.SESSION_COOKIE_NAME = void 0;
    exports.SESSION_COOKIE_NAME = "shopify_app_session";
    exports.STATE_COOKIE_NAME = "shopify_app_state";
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/nonce.js
var require_nonce = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/nonce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nonce = void 0;
    var crypto_1 = require_crypto();
    function nonce() {
      const length = 15;
      const bytes = crypto_1.crypto.getRandomValues ? crypto_1.crypto.getRandomValues(new Uint8Array(length)) : crypto_1.crypto.randomBytes(length);
      const nonce2 = bytes.map((byte) => {
        return byte % 10;
      }).join("");
      return nonce2;
    }
    exports.nonce = nonce;
  }
});

// node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default = v1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.URL = exports.DNS = void 0;
    exports.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL2;
    function v35(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/native.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID
    };
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/nil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/version.js
var require_version2 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    var _default = version;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function get() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function get() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function get() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function get() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function get() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function get() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version2());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@shopify/shopify-api/lib/session/session.js
var require_session = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var error_1 = require_error();
    var scopes_1 = require_scopes();
    var propertiesToSave = [
      "id",
      "shop",
      "state",
      "isOnline",
      "scope",
      "accessToken",
      "expires",
      "onlineAccessInfo"
    ];
    var Session2 = class _Session {
      static fromPropertyArray(entries, returnUserData = false) {
        if (!Array.isArray(entries)) {
          throw new error_1.InvalidSession("The parameter is not an array: a Session cannot be created from this object.");
        }
        const obj = Object.fromEntries(entries.filter(([_key, value]) => value !== null && value !== void 0).map(([key, value]) => {
          switch (key.toLowerCase()) {
            case "isonline":
              return ["isOnline", value];
            case "accesstoken":
              return ["accessToken", value];
            case "onlineaccessinfo":
              return ["onlineAccessInfo", value];
            case "userid":
              return ["userId", value];
            case "firstname":
              return ["firstName", value];
            case "lastname":
              return ["lastName", value];
            case "accountowner":
              return ["accountOwner", value];
            case "emailverified":
              return ["emailVerified", value];
            default:
              return [key.toLowerCase(), value];
          }
        }));
        const sessionData = {};
        const onlineAccessInfo = {
          associated_user: {}
        };
        Object.entries(obj).forEach(([key, value]) => {
          switch (key) {
            case "isOnline":
              if (typeof value === "string") {
                sessionData[key] = value.toString().toLowerCase() === "true";
              } else if (typeof value === "number") {
                sessionData[key] = Boolean(value);
              } else {
                sessionData[key] = value;
              }
              break;
            case "scope":
              sessionData[key] = value.toString();
              break;
            case "expires":
              sessionData[key] = value ? new Date(Number(value)) : void 0;
              break;
            case "onlineAccessInfo":
              onlineAccessInfo.associated_user.id = Number(value);
              break;
            case "userId":
              if (returnUserData) {
                onlineAccessInfo.associated_user.id = Number(value);
                break;
              }
            case "firstName":
              if (returnUserData) {
                onlineAccessInfo.associated_user.first_name = String(value);
                break;
              }
            case "lastName":
              if (returnUserData) {
                onlineAccessInfo.associated_user.last_name = String(value);
                break;
              }
            case "email":
              if (returnUserData) {
                onlineAccessInfo.associated_user.email = String(value);
                break;
              }
            case "accountOwner":
              if (returnUserData) {
                onlineAccessInfo.associated_user.account_owner = Boolean(value);
                break;
              }
            case "locale":
              if (returnUserData) {
                onlineAccessInfo.associated_user.locale = String(value);
                break;
              }
            case "collaborator":
              if (returnUserData) {
                onlineAccessInfo.associated_user.collaborator = Boolean(value);
                break;
              }
            case "emailVerified":
              if (returnUserData) {
                onlineAccessInfo.associated_user.email_verified = Boolean(value);
                break;
              }
            default:
              sessionData[key] = value;
          }
        });
        if (sessionData.isOnline) {
          sessionData.onlineAccessInfo = onlineAccessInfo;
        }
        const session = new _Session(sessionData);
        return session;
      }
      constructor(params) {
        Object.assign(this, params);
      }
      /**
       * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.
       */
      isActive(scopes) {
        return !this.isScopeChanged(scopes) && Boolean(this.accessToken) && !this.isExpired();
      }
      /**
       * Whether the access token has the given scopes.
       */
      isScopeChanged(scopes) {
        const scopesObject = scopes instanceof scopes_1.AuthScopes ? scopes : new scopes_1.AuthScopes(scopes);
        return !scopesObject.equals(this.scope);
      }
      /**
       * Whether the access token is expired.
       */
      isExpired(withinMillisecondsOfExpiry = 0) {
        return Boolean(this.expires && this.expires.getTime() - withinMillisecondsOfExpiry < Date.now());
      }
      /**
       * Converts an object with data into a Session.
       */
      toObject() {
        const object = {
          id: this.id,
          shop: this.shop,
          state: this.state,
          isOnline: this.isOnline
        };
        if (this.scope) {
          object.scope = this.scope;
        }
        if (this.expires) {
          object.expires = this.expires;
        }
        if (this.accessToken) {
          object.accessToken = this.accessToken;
        }
        if (this.onlineAccessInfo) {
          object.onlineAccessInfo = this.onlineAccessInfo;
        }
        return object;
      }
      /**
       * Checks whether the given session is equal to this session.
       */
      equals(other) {
        if (!other)
          return false;
        const mandatoryPropsMatch = this.id === other.id && this.shop === other.shop && this.state === other.state && this.isOnline === other.isOnline;
        if (!mandatoryPropsMatch)
          return false;
        const copyA = this.toPropertyArray(true);
        copyA.sort(([k1], [k2]) => k1 < k2 ? -1 : 1);
        const copyB = other.toPropertyArray(true);
        copyB.sort(([k1], [k2]) => k1 < k2 ? -1 : 1);
        return JSON.stringify(copyA) === JSON.stringify(copyB);
      }
      /**
       * Converts the session into an array of key-value pairs.
       */
      toPropertyArray(returnUserData = false) {
        return Object.entries(this).filter(([key, value]) => propertiesToSave.includes(key) && value !== void 0 && value !== null).flatMap(([key, value]) => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          switch (key) {
            case "expires":
              return [[key, value ? value.getTime() : void 0]];
            case "onlineAccessInfo":
              if (!returnUserData) {
                return [[key, value.associated_user.id]];
              } else {
                return [
                  ["userId", (_a = value == null ? void 0 : value.associated_user) == null ? void 0 : _a.id],
                  ["firstName", (_b = value == null ? void 0 : value.associated_user) == null ? void 0 : _b.first_name],
                  ["lastName", (_c = value == null ? void 0 : value.associated_user) == null ? void 0 : _c.last_name],
                  ["email", (_d = value == null ? void 0 : value.associated_user) == null ? void 0 : _d.email],
                  ["locale", (_e = value == null ? void 0 : value.associated_user) == null ? void 0 : _e.locale],
                  ["emailVerified", (_f = value == null ? void 0 : value.associated_user) == null ? void 0 : _f.email_verified],
                  ["accountOwner", (_g = value == null ? void 0 : value.associated_user) == null ? void 0 : _g.account_owner],
                  ["collaborator", (_h = value == null ? void 0 : value.associated_user) == null ? void 0 : _h.collaborator]
                ];
              }
            default:
              return [[key, value]];
          }
        }).filter(([_key, value]) => value !== void 0);
      }
    };
    exports.Session = Session2;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/get-hmac-key.js
var require_get_hmac_key = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/get-hmac-key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHMACKey = void 0;
    function getHMACKey(key) {
      const arrayBuffer = new Uint8Array(key.length);
      for (let i = 0, keyLen = key.length; i < keyLen; i++) {
        arrayBuffer[i] = key.charCodeAt(i);
      }
      return arrayBuffer;
    }
    exports.getHMACKey = getHMACKey;
  }
});

// node_modules/@shopify/shopify-api/lib/session/decode-session-token.js
var require_decode_session_token = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/decode-session-token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSessionToken = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jose = tslib_1.__importStar((init_browser(), __toCommonJS(browser_exports)));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var get_hmac_key_1 = require_get_hmac_key();
    var JWT_PERMITTED_CLOCK_TOLERANCE = 10;
    function decodeSessionToken(config) {
      return async (token, { checkAudience = true } = {}) => {
        let payload;
        try {
          payload = (await jose.jwtVerify(token, (0, get_hmac_key_1.getHMACKey)(config.apiSecretKey), {
            algorithms: ["HS256"],
            clockTolerance: JWT_PERMITTED_CLOCK_TOLERANCE
          })).payload;
        } catch (error) {
          throw new ShopifyErrors.InvalidJwtError(`Failed to parse session token '${token}': ${error.message}`);
        }
        if (checkAudience && payload.aud !== config.apiKey) {
          throw new ShopifyErrors.InvalidJwtError("Session token had invalid API key");
        }
        return payload;
      };
    }
    exports.decodeSessionToken = decodeSessionToken;
  }
});

// node_modules/@shopify/shopify-api/lib/session/session-utils.js
var require_session_utils = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/session-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.customAppSession = exports.getCurrentSessionId = exports.getOfflineId = exports.getJwtSessionId = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var types_1 = require_types5();
    var http_1 = require_http();
    var shop_validator_1 = require_shop_validator();
    var logger_1 = require_logger();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var decode_session_token_1 = require_decode_session_token();
    var session_1 = require_session();
    function getJwtSessionId(config) {
      return (shop, userId) => {
        return `${(0, shop_validator_1.sanitizeShop)(config)(shop, true)}_${userId}`;
      };
    }
    exports.getJwtSessionId = getJwtSessionId;
    function getOfflineId(config) {
      return (shop) => {
        return `offline_${(0, shop_validator_1.sanitizeShop)(config)(shop, true)}`;
      };
    }
    exports.getOfflineId = getOfflineId;
    function getCurrentSessionId(config) {
      return async function getCurrentSessionId2({ isOnline, ...adapterArgs }) {
        const request = await (0, http_1.abstractConvertRequest)(adapterArgs);
        const log = (0, logger_1.logger)(config);
        if (config.isEmbeddedApp) {
          log.debug("App is embedded, looking for session id in JWT payload", {
            isOnline
          });
          const authHeader = request.headers.Authorization;
          if (authHeader) {
            const matches = (typeof authHeader === "string" ? authHeader : authHeader[0]).match(/^Bearer (.+)$/);
            if (!matches) {
              log.error("Missing Bearer token in authorization header", { isOnline });
              throw new ShopifyErrors.MissingJwtTokenError("Missing Bearer token in authorization header");
            }
            const jwtPayload = await (0, decode_session_token_1.decodeSessionToken)(config)(matches[1]);
            const shop = jwtPayload.dest.replace(/^https:\/\//, "");
            log.debug("Found valid JWT payload", { shop, isOnline });
            if (isOnline) {
              return getJwtSessionId(config)(shop, jwtPayload.sub);
            } else {
              return getOfflineId(config)(shop);
            }
          } else {
            log.error("Missing Authorization header, was the request made with authenticatedFetch?", { isOnline });
          }
        } else {
          log.debug("App is not embedded, looking for session id in cookies", {
            isOnline
          });
          const cookies = new http_1.Cookies(request, {}, {
            keys: [config.apiSecretKey]
          });
          return cookies.getAndVerify(types_1.SESSION_COOKIE_NAME);
        }
        return void 0;
      };
    }
    exports.getCurrentSessionId = getCurrentSessionId;
    function customAppSession(config) {
      return (shop) => {
        return new session_1.Session({
          id: "",
          shop: `${(0, shop_validator_1.sanitizeShop)(config)(shop, true)}`,
          state: "",
          isOnline: false
        });
      };
    }
    exports.customAppSession = customAppSession;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/create-session.js
var require_create_session = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/create-session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSession = void 0;
    var uuid_1 = require_commonjs_browser();
    var session_1 = require_session();
    var logger_1 = require_logger();
    var session_utils_1 = require_session_utils();
    function createSession({ config, accessTokenResponse, shop, state }) {
      const associatedUser = accessTokenResponse.associated_user;
      const isOnline = Boolean(associatedUser);
      (0, logger_1.logger)(config).info("Creating new session", { shop, isOnline });
      if (isOnline) {
        let sessionId;
        const responseBody = accessTokenResponse;
        const { access_token, scope, ...rest } = responseBody;
        const sessionExpiration = new Date(Date.now() + responseBody.expires_in * 1e3);
        if (config.isEmbeddedApp) {
          sessionId = (0, session_utils_1.getJwtSessionId)(config)(shop, `${rest.associated_user.id}`);
        } else {
          sessionId = (0, uuid_1.v4)();
        }
        return new session_1.Session({
          id: sessionId,
          shop,
          state,
          isOnline,
          accessToken: access_token,
          scope,
          expires: sessionExpiration,
          onlineAccessInfo: rest
        });
      } else {
        return new session_1.Session({
          id: (0, session_utils_1.getOfflineId)(config)(shop),
          shop,
          state,
          isOnline,
          accessToken: accessTokenResponse.access_token,
          scope: accessTokenResponse.scope
        });
      }
    }
    exports.createSession = createSession;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/oauth.js
var require_oauth = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/oauth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callback = exports.begin = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var isbot_1 = require_isbot();
    var common_1 = require_common();
    var processed_query_1 = tslib_1.__importDefault(require_processed_query());
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var hmac_validator_1 = require_hmac_validator();
    var shop_validator_1 = require_shop_validator();
    var http_1 = require_http();
    var logger_1 = require_logger();
    var types_1 = require_types3();
    var fetch_request_1 = require_fetch_request();
    var types_2 = require_types5();
    var nonce_1 = require_nonce();
    var safe_compare_1 = require_safe_compare();
    var create_session_1 = require_create_session();
    var logForBot = ({ request, log, func }) => {
      log.debug(`Possible bot request to auth ${func}: `, {
        userAgent: request.headers["User-Agent"]
      });
    };
    function begin(config) {
      return async ({ shop, callbackPath, isOnline, ...adapterArgs }) => {
        throwIfCustomStoreApp(config.isCustomStoreApp, "Cannot perform OAuth for private apps");
        const log = (0, logger_1.logger)(config);
        log.info("Beginning OAuth", { shop, isOnline, callbackPath });
        const request = await (0, http_1.abstractConvertRequest)(adapterArgs);
        const response = await (0, http_1.abstractConvertIncomingResponse)(adapterArgs);
        let userAgent = request.headers["User-Agent"];
        if (Array.isArray(userAgent)) {
          userAgent = userAgent[0];
        }
        if ((0, isbot_1.isbot)(userAgent)) {
          logForBot({ request, log, func: "begin" });
          response.statusCode = 410;
          return (0, http_1.abstractConvertResponse)(response, adapterArgs);
        }
        const cookies = new http_1.Cookies(request, response, {
          keys: [config.apiSecretKey],
          secure: true
        });
        const state = (0, nonce_1.nonce)();
        await cookies.setAndSign(types_2.STATE_COOKIE_NAME, state, {
          expires: new Date(Date.now() + 6e4),
          sameSite: "lax",
          secure: true,
          path: callbackPath
        });
        const query = {
          client_id: config.apiKey,
          scope: config.scopes.toString(),
          redirect_uri: `${config.hostScheme}://${config.hostName}${callbackPath}`,
          state,
          "grant_options[]": isOnline ? "per-user" : ""
        };
        const processedQuery = new processed_query_1.default();
        processedQuery.putAll(query);
        const cleanShop = (0, shop_validator_1.sanitizeShop)(config)(shop, true);
        const redirectUrl = `https://${cleanShop}/admin/oauth/authorize${processedQuery.stringify()}`;
        response.statusCode = 302;
        response.statusText = "Found";
        response.headers = {
          ...response.headers,
          ...cookies.response.headers,
          Location: redirectUrl
        };
        log.debug(`OAuth started, redirecting to ${redirectUrl}`, { shop, isOnline });
        return (0, http_1.abstractConvertResponse)(response, adapterArgs);
      };
    }
    exports.begin = begin;
    function callback(config) {
      return async function callback2({ ...adapterArgs }) {
        throwIfCustomStoreApp(config.isCustomStoreApp, "Cannot perform OAuth for private apps");
        const log = (0, logger_1.logger)(config);
        const request = await (0, http_1.abstractConvertRequest)(adapterArgs);
        const query = new URL(request.url, `${config.hostScheme}://${config.hostName}`).searchParams;
        const shop = query.get("shop");
        const response = {};
        let userAgent = request.headers["User-Agent"];
        if (Array.isArray(userAgent)) {
          userAgent = userAgent[0];
        }
        if ((0, isbot_1.isbot)(userAgent)) {
          logForBot({ request, log, func: "callback" });
          throw new ShopifyErrors.BotActivityDetected("Invalid OAuth callback initiated by bot");
        }
        log.info("Completing OAuth", { shop });
        const cookies = new http_1.Cookies(request, response, {
          keys: [config.apiSecretKey],
          secure: true
        });
        const stateFromCookie = await cookies.getAndVerify(types_2.STATE_COOKIE_NAME);
        cookies.deleteCookie(types_2.STATE_COOKIE_NAME);
        if (!stateFromCookie) {
          log.error("Could not find OAuth cookie", { shop });
          throw new ShopifyErrors.CookieNotFound(`Cannot complete OAuth process. Could not find an OAuth cookie for shop url: ${shop}`);
        }
        const authQuery = Object.fromEntries(query.entries());
        if (!await validQuery({ config, query: authQuery, stateFromCookie })) {
          log.error("Invalid OAuth callback", { shop, stateFromCookie });
          throw new ShopifyErrors.InvalidOAuthError("Invalid OAuth callback.");
        }
        log.debug("OAuth request is valid, requesting access token", { shop });
        const body = {
          client_id: config.apiKey,
          client_secret: config.apiSecretKey,
          code: query.get("code")
        };
        const cleanShop = (0, shop_validator_1.sanitizeShop)(config)(query.get("shop"), true);
        const postResponse = await (0, fetch_request_1.fetchRequestFactory)(config)(`https://${cleanShop}/admin/oauth/access_token`, {
          method: "POST",
          body: JSON.stringify(body),
          headers: {
            "Content-Type": types_1.DataType.JSON,
            Accept: types_1.DataType.JSON
          }
        });
        if (!postResponse.ok) {
          (0, common_1.throwFailedRequest)(await postResponse.json(), false, postResponse);
        }
        const session = (0, create_session_1.createSession)({
          accessTokenResponse: await postResponse.json(),
          shop: cleanShop,
          state: stateFromCookie,
          config
        });
        if (!config.isEmbeddedApp) {
          await cookies.setAndSign(types_2.SESSION_COOKIE_NAME, session.id, {
            expires: session.expires,
            sameSite: "lax",
            secure: true,
            path: "/"
          });
        }
        return {
          headers: await (0, http_1.abstractConvertHeaders)(cookies.response.headers, adapterArgs),
          session
        };
      };
    }
    exports.callback = callback;
    async function validQuery({ config, query, stateFromCookie }) {
      return await (0, hmac_validator_1.validateHmac)(config)(query) && (0, safe_compare_1.safeCompare)(query.state, stateFromCookie);
    }
    function throwIfCustomStoreApp(isCustomStoreApp, message) {
      if (isCustomStoreApp) {
        throw new ShopifyErrors.PrivateAppError(message);
      }
    }
  }
});

// node_modules/@shopify/shopify-api/lib/auth/get-embedded-app-url.js
var require_get_embedded_app_url = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/get-embedded-app-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildEmbeddedAppUrl = exports.getEmbeddedAppUrl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var http_1 = require_http();
    var shop_validator_1 = require_shop_validator();
    var decode_host_1 = require_decode_host();
    function getEmbeddedAppUrl(config) {
      return async ({ ...adapterArgs }) => {
        const request = await (0, http_1.abstractConvertRequest)(adapterArgs);
        if (!request) {
          throw new ShopifyErrors.MissingRequiredArgument("getEmbeddedAppUrl requires a request object argument");
        }
        if (!request.url) {
          throw new ShopifyErrors.InvalidRequestError("Request does not contain a URL");
        }
        const url = new URL(request.url, `https://${request.headers.host}`);
        const host = url.searchParams.get("host");
        if (typeof host !== "string") {
          throw new ShopifyErrors.InvalidRequestError("Request does not contain a host query parameter");
        }
        return buildEmbeddedAppUrl(config)(host);
      };
    }
    exports.getEmbeddedAppUrl = getEmbeddedAppUrl;
    function buildEmbeddedAppUrl(config) {
      return (host) => {
        (0, shop_validator_1.sanitizeHost)()(host, true);
        const decodedHost = (0, decode_host_1.decodeHost)(host);
        return `https://${decodedHost}/apps/${config.apiKey}`;
      };
    }
    exports.buildEmbeddedAppUrl = buildEmbeddedAppUrl;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/token-exchange.js
var require_token_exchange = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/token-exchange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenExchange = exports.RequestedTokenType = void 0;
    var common_1 = require_common();
    var decode_session_token_1 = require_decode_session_token();
    var shop_validator_1 = require_shop_validator();
    var types_1 = require_types3();
    var fetch_request_1 = require_fetch_request();
    var create_session_1 = require_create_session();
    var RequestedTokenType;
    (function(RequestedTokenType2) {
      RequestedTokenType2["OnlineAccessToken"] = "urn:shopify:params:oauth:token-type:online-access-token";
      RequestedTokenType2["OfflineAccessToken"] = "urn:shopify:params:oauth:token-type:offline-access-token";
    })(RequestedTokenType || (exports.RequestedTokenType = RequestedTokenType = {}));
    var TokenExchangeGrantType = "urn:ietf:params:oauth:grant-type:token-exchange";
    var IdTokenType = "urn:ietf:params:oauth:token-type:id_token";
    function tokenExchange(config) {
      return async ({ shop, sessionToken, requestedTokenType }) => {
        await (0, decode_session_token_1.decodeSessionToken)(config)(sessionToken);
        const body = {
          client_id: config.apiKey,
          client_secret: config.apiSecretKey,
          grant_type: TokenExchangeGrantType,
          subject_token: sessionToken,
          subject_token_type: IdTokenType,
          requested_token_type: requestedTokenType
        };
        const cleanShop = (0, shop_validator_1.sanitizeShop)(config)(shop, true);
        const postResponse = await (0, fetch_request_1.fetchRequestFactory)(config)(`https://${cleanShop}/admin/oauth/access_token`, {
          method: "POST",
          body: JSON.stringify(body),
          headers: {
            "Content-Type": types_1.DataType.JSON,
            Accept: types_1.DataType.JSON
          }
        });
        if (!postResponse.ok) {
          (0, common_1.throwFailedRequest)(await postResponse.json(), false, postResponse);
        }
        return {
          session: (0, create_session_1.createSession)({
            accessTokenResponse: await postResponse.json(),
            shop: cleanShop,
            // We need to keep this as an empty string as our template DB schemas have this required
            state: "",
            config
          })
        };
      };
    }
    exports.tokenExchange = tokenExchange;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/index.js
var require_auth = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyAuth = void 0;
    var oauth_1 = require_oauth();
    var nonce_1 = require_nonce();
    var safe_compare_1 = require_safe_compare();
    var get_embedded_app_url_1 = require_get_embedded_app_url();
    var token_exchange_1 = require_token_exchange();
    function shopifyAuth(config) {
      const shopify = {
        begin: (0, oauth_1.begin)(config),
        callback: (0, oauth_1.callback)(config),
        nonce: nonce_1.nonce,
        safeCompare: safe_compare_1.safeCompare,
        getEmbeddedAppUrl: (0, get_embedded_app_url_1.getEmbeddedAppUrl)(config),
        buildEmbeddedAppUrl: (0, get_embedded_app_url_1.buildEmbeddedAppUrl)(config),
        tokenExchange: (0, token_exchange_1.tokenExchange)(config)
      };
      return shopify;
    }
    exports.shopifyAuth = shopifyAuth;
  }
});

// node_modules/@shopify/shopify-api/lib/session/index.js
var require_session2 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifySession = void 0;
    var decode_session_token_1 = require_decode_session_token();
    var session_utils_1 = require_session_utils();
    function shopifySession(config) {
      return {
        customAppSession: (0, session_utils_1.customAppSession)(config),
        getCurrentId: (0, session_utils_1.getCurrentSessionId)(config),
        getOfflineId: (0, session_utils_1.getOfflineId)(config),
        getJwtSessionId: (0, session_utils_1.getJwtSessionId)(config),
        decodeSessionToken: (0, decode_session_token_1.decodeSessionToken)(config)
      };
    }
    exports.shopifySession = shopifySession;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/version-compatible.js
var require_version_compatible = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/version-compatible.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.versionPriorTo = exports.versionCompatible = void 0;
    var types_1 = require_types();
    function versionCompatible(config) {
      return (referenceVersion, currentVersion = config.apiVersion) => {
        if (currentVersion === types_1.ApiVersion.Unstable) {
          return true;
        }
        const numericVersion = (version) => parseInt(version.replace("-", ""), 10);
        const current = numericVersion(currentVersion);
        const reference = numericVersion(referenceVersion);
        return current >= reference;
      };
    }
    exports.versionCompatible = versionCompatible;
    function versionPriorTo(config) {
      return (referenceVersion, currentVersion = config.apiVersion) => {
        return !versionCompatible(config)(referenceVersion, currentVersion);
      };
    }
    exports.versionPriorTo = versionPriorTo;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyUtils = void 0;
    var shop_validator_1 = require_shop_validator();
    var hmac_validator_1 = require_hmac_validator();
    var version_compatible_1 = require_version_compatible();
    var shop_admin_url_helper_1 = require_shop_admin_url_helper();
    function shopifyUtils(config) {
      return {
        sanitizeShop: (0, shop_validator_1.sanitizeShop)(config),
        sanitizeHost: (0, shop_validator_1.sanitizeHost)(),
        validateHmac: (0, hmac_validator_1.validateHmac)(config),
        versionCompatible: (0, version_compatible_1.versionCompatible)(config),
        versionPriorTo: (0, version_compatible_1.versionPriorTo)(config),
        shopAdminUrlToLegacyUrl: shop_admin_url_helper_1.shopAdminUrlToLegacyUrl,
        legacyUrlToShopAdminUrl: shop_admin_url_helper_1.legacyUrlToShopAdminUrl
      };
    }
    exports.shopifyUtils = shopifyUtils;
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/types.js
var require_types6 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebhookValidationErrorReason = exports.WebhookOperation = exports.DeliveryMethod = void 0;
    var types_1 = require_types4();
    var DeliveryMethod;
    (function(DeliveryMethod2) {
      DeliveryMethod2["Http"] = "http";
      DeliveryMethod2["EventBridge"] = "eventbridge";
      DeliveryMethod2["PubSub"] = "pubsub";
    })(DeliveryMethod || (exports.DeliveryMethod = DeliveryMethod = {}));
    var WebhookOperation;
    (function(WebhookOperation2) {
      WebhookOperation2["Create"] = "create";
      WebhookOperation2["Update"] = "update";
      WebhookOperation2["Delete"] = "delete";
    })(WebhookOperation || (exports.WebhookOperation = WebhookOperation = {}));
    exports.WebhookValidationErrorReason = {
      ...types_1.ValidationErrorReason,
      MissingHeaders: "missing_headers"
    };
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/registry.js
var require_registry = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHostToCallbackUrl = exports.handlerIdentifier = exports.getHandlers = exports.getTopicsAdded = exports.addHandlers = exports.topicForStorage = exports.registry = void 0;
    var error_1 = require_error();
    var logger_1 = require_logger();
    var types_1 = require_types6();
    function registry() {
      return {};
    }
    exports.registry = registry;
    function topicForStorage(topic) {
      return topic.toUpperCase().replace(/\/|\./g, "_");
    }
    exports.topicForStorage = topicForStorage;
    function addHandlers(config, webhookRegistry) {
      return function addHandlers2(handlersToAdd) {
        for (const [topic, handlers] of Object.entries(handlersToAdd)) {
          const topicKey = topicForStorage(topic);
          if (Array.isArray(handlers)) {
            for (const handler of handlers) {
              mergeOrAddHandler(config, webhookRegistry, topicKey, handler);
            }
          } else {
            mergeOrAddHandler(config, webhookRegistry, topicKey, handlers);
          }
        }
      };
    }
    exports.addHandlers = addHandlers;
    function getTopicsAdded(webhookRegistry) {
      return function getTopicsAdded2() {
        return Object.keys(webhookRegistry);
      };
    }
    exports.getTopicsAdded = getTopicsAdded;
    function getHandlers(webhookRegistry) {
      return function getHandlers2(topic) {
        return webhookRegistry[topicForStorage(topic)] || [];
      };
    }
    exports.getHandlers = getHandlers;
    function handlerIdentifier(config, handler) {
      const prefix = handler.deliveryMethod;
      switch (handler.deliveryMethod) {
        case types_1.DeliveryMethod.Http:
          return `${prefix}_${addHostToCallbackUrl(config, handler.callbackUrl)}`;
        case types_1.DeliveryMethod.EventBridge:
          return `${prefix}_${handler.arn}`;
        case types_1.DeliveryMethod.PubSub:
          return `${prefix}_${handler.pubSubProject}:${handler.pubSubTopic}`;
        default:
          throw new error_1.InvalidDeliveryMethodError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
      }
    }
    exports.handlerIdentifier = handlerIdentifier;
    function addHostToCallbackUrl(config, callbackUrl) {
      if (callbackUrl.startsWith("/")) {
        return `${config.hostScheme}://${config.hostName}${callbackUrl}`;
      } else {
        return callbackUrl;
      }
    }
    exports.addHostToCallbackUrl = addHostToCallbackUrl;
    function mergeOrAddHandler(config, webhookRegistry, topic, handler) {
      var _a, _b;
      const log = (0, logger_1.logger)(config);
      (_a = handler.includeFields) == null ? void 0 : _a.sort();
      (_b = handler.metafieldNamespaces) == null ? void 0 : _b.sort();
      if (!(topic in webhookRegistry)) {
        webhookRegistry[topic] = [handler];
        return;
      }
      const identifier = handlerIdentifier(config, handler);
      for (const index in webhookRegistry[topic]) {
        if (!Object.prototype.hasOwnProperty.call(webhookRegistry[topic], index)) {
          continue;
        }
        const existingHandler = webhookRegistry[topic][index];
        const existingIdentifier = handlerIdentifier(config, existingHandler);
        if (identifier !== existingIdentifier) {
          continue;
        }
        if (handler.deliveryMethod === types_1.DeliveryMethod.Http) {
          log.info(`Detected multiple handlers for '${topic}', webhooks.process will call them sequentially`);
          break;
        } else {
          throw new error_1.InvalidDeliveryMethodError(`Can only add multiple handlers for a topic when deliveryMethod is Http. Please be sure that you used addHandler method once after creating ShopifyApi instance in your app.  Invalid handler: ${JSON.stringify(handler)}`);
        }
      }
      webhookRegistry[topic].push(handler);
    }
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/query-template.js
var require_query_template = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/query-template.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queryTemplate = void 0;
    function queryTemplate(template, params) {
      let query = template;
      Object.entries(params).forEach(([key, value]) => {
        query = query.replace(`{{${key}}}`, value);
      });
      return query;
    }
    exports.queryTemplate = queryTemplate;
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/register.js
var require_register = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/register.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TEMPLATE_MUTATION = exports.TEMPLATE_GET_HANDLERS = exports.register = void 0;
    var admin_1 = require_admin();
    var error_1 = require_error();
    var logger_1 = require_logger();
    var types_1 = require_types();
    var registry_1 = require_registry();
    var query_template_1 = require_query_template();
    var types_2 = require_types6();
    function register(config, webhookRegistry) {
      return async function register2({ session }) {
        const log = (0, logger_1.logger)(config);
        log.info("Registering webhooks", { shop: session.shop });
        const registerReturn = Object.keys(webhookRegistry).reduce((acc, topic) => {
          acc[topic] = [];
          return acc;
        }, {});
        const existingHandlers = await getExistingHandlers(config, session);
        log.debug(`Existing topics: [${Object.keys(existingHandlers).join(", ")}]`, { shop: session.shop });
        for (const topic in webhookRegistry) {
          if (!Object.prototype.hasOwnProperty.call(webhookRegistry, topic)) {
            continue;
          }
          if (types_1.privacyTopics.includes(topic)) {
            continue;
          }
          registerReturn[topic] = await registerTopic({
            config,
            session,
            topic,
            existingHandlers: existingHandlers[topic] || [],
            handlers: (0, registry_1.getHandlers)(webhookRegistry)(topic)
          });
          delete existingHandlers[topic];
        }
        for (const topic in existingHandlers) {
          if (!Object.prototype.hasOwnProperty.call(existingHandlers, topic)) {
            continue;
          }
          const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
          const client = new GraphqlClient({ session });
          registerReturn[topic] = await runMutations({
            config,
            client,
            topic,
            handlers: existingHandlers[topic],
            operation: types_2.WebhookOperation.Delete
          });
        }
        return registerReturn;
      };
    }
    exports.register = register;
    async function getExistingHandlers(config, session) {
      var _a, _b, _c, _d, _e, _f;
      const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
      const client = new GraphqlClient({ session });
      const existingHandlers = {};
      let hasNextPage;
      let endCursor = null;
      do {
        const query = buildCheckQuery(endCursor);
        const response = await client.request(query);
        (_b = (_a = response.data) == null ? void 0 : _a.webhookSubscriptions) == null ? void 0 : _b.edges.forEach((edge) => {
          const handler = buildHandlerFromNode(edge);
          if (!existingHandlers[edge.node.topic]) {
            existingHandlers[edge.node.topic] = [];
          }
          existingHandlers[edge.node.topic].push(handler);
        });
        endCursor = (_d = (_c = response.data) == null ? void 0 : _c.webhookSubscriptions) == null ? void 0 : _d.pageInfo.endCursor;
        hasNextPage = (_f = (_e = response.data) == null ? void 0 : _e.webhookSubscriptions) == null ? void 0 : _f.pageInfo.hasNextPage;
      } while (hasNextPage);
      return existingHandlers;
    }
    function buildCheckQuery(endCursor) {
      return (0, query_template_1.queryTemplate)(exports.TEMPLATE_GET_HANDLERS, {
        END_CURSOR: JSON.stringify(endCursor)
      });
    }
    function buildHandlerFromNode(edge) {
      var _a, _b;
      const endpoint = edge.node.endpoint;
      let handler;
      switch (endpoint.__typename) {
        case "WebhookHttpEndpoint":
          handler = {
            deliveryMethod: types_2.DeliveryMethod.Http,
            callbackUrl: endpoint.callbackUrl,
            // This is a dummy for now because we don't really care about it
            callback: async () => {
            }
          };
          break;
        case "WebhookEventBridgeEndpoint":
          handler = {
            deliveryMethod: types_2.DeliveryMethod.EventBridge,
            arn: endpoint.arn
          };
          break;
        case "WebhookPubSubEndpoint":
          handler = {
            deliveryMethod: types_2.DeliveryMethod.PubSub,
            pubSubProject: endpoint.pubSubProject,
            pubSubTopic: endpoint.pubSubTopic
          };
          break;
      }
      handler.id = edge.node.id;
      handler.includeFields = edge.node.includeFields;
      handler.metafieldNamespaces = edge.node.metafieldNamespaces;
      (_a = handler.includeFields) == null ? void 0 : _a.sort();
      (_b = handler.metafieldNamespaces) == null ? void 0 : _b.sort();
      return handler;
    }
    async function registerTopic({ config, session, topic, existingHandlers, handlers }) {
      let registerResults = [];
      const { toCreate, toUpdate, toDelete } = categorizeHandlers(config, existingHandlers, handlers);
      const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
      const client = new GraphqlClient({ session });
      let operation = types_2.WebhookOperation.Create;
      registerResults = registerResults.concat(await runMutations({ config, client, topic, operation, handlers: toCreate }));
      operation = types_2.WebhookOperation.Update;
      registerResults = registerResults.concat(await runMutations({ config, client, topic, operation, handlers: toUpdate }));
      operation = types_2.WebhookOperation.Delete;
      registerResults = registerResults.concat(await runMutations({ config, client, topic, operation, handlers: toDelete }));
      return registerResults;
    }
    function categorizeHandlers(config, existingHandlers, handlers) {
      const handlersByKey = handlers.reduce((acc, value) => {
        acc[(0, registry_1.handlerIdentifier)(config, value)] = value;
        return acc;
      }, {});
      const existingHandlersByKey = existingHandlers.reduce((acc, value) => {
        acc[(0, registry_1.handlerIdentifier)(config, value)] = value;
        return acc;
      }, {});
      const toCreate = { ...handlersByKey };
      const toUpdate = {};
      const toDelete = {};
      for (const existingKey in existingHandlersByKey) {
        if (!Object.prototype.hasOwnProperty.call(existingHandlersByKey, existingKey)) {
          continue;
        }
        const existingHandler = existingHandlersByKey[existingKey];
        const handler = handlersByKey[existingKey];
        if (existingKey in handlersByKey) {
          delete toCreate[existingKey];
          if (!areHandlerFieldsEqual(existingHandler, handler)) {
            toUpdate[existingKey] = handler;
            toUpdate[existingKey].id = existingHandler.id;
          }
        } else {
          toDelete[existingKey] = existingHandler;
        }
      }
      return {
        toCreate: Object.values(toCreate),
        toUpdate: Object.values(toUpdate),
        toDelete: Object.values(toDelete)
      };
    }
    function areHandlerFieldsEqual(arr1, arr2) {
      const includeFieldsEqual = arraysEqual(arr1.includeFields || [], arr2.includeFields || []);
      const metafieldNamespacesEqual = arraysEqual(arr1.metafieldNamespaces || [], arr2.metafieldNamespaces || []);
      return includeFieldsEqual && metafieldNamespacesEqual;
    }
    function arraysEqual(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }
      for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
          return false;
        }
      }
      return true;
    }
    async function runMutations({ config, client, topic, handlers, operation }) {
      const registerResults = [];
      for (const handler of handlers) {
        registerResults.push(await runMutation({ config, client, topic, handler, operation }));
      }
      return registerResults;
    }
    async function runMutation({ config, client, topic, handler, operation }) {
      let registerResult;
      (0, logger_1.logger)(config).debug(`Running webhook mutation`, { topic, operation });
      try {
        const query = buildMutation(config, topic, handler, operation);
        const result = await client.request(query);
        registerResult = {
          deliveryMethod: handler.deliveryMethod,
          success: isSuccess(result, handler, operation),
          result,
          operation
        };
      } catch (error) {
        if (error instanceof error_1.InvalidDeliveryMethodError) {
          registerResult = {
            deliveryMethod: handler.deliveryMethod,
            success: false,
            result: { message: error.message },
            operation
          };
        } else {
          throw error;
        }
      }
      return registerResult;
    }
    function buildMutation(config, topic, handler, operation) {
      const params = {};
      let identifier;
      if (handler.id) {
        identifier = `id: "${handler.id}"`;
      } else {
        identifier = `topic: ${topic}`;
      }
      const mutationArguments = {
        MUTATION_NAME: getMutationName(handler, operation),
        IDENTIFIER: identifier,
        MUTATION_PARAMS: ""
      };
      if (operation !== types_2.WebhookOperation.Delete) {
        switch (handler.deliveryMethod) {
          case types_2.DeliveryMethod.Http:
            params.callbackUrl = `"${(0, registry_1.addHostToCallbackUrl)(config, handler.callbackUrl)}"`;
            break;
          case types_2.DeliveryMethod.EventBridge:
            params.arn = `"${handler.arn}"`;
            break;
          case types_2.DeliveryMethod.PubSub:
            params.pubSubProject = `"${handler.pubSubProject}"`;
            params.pubSubTopic = `"${handler.pubSubTopic}"`;
            break;
          default:
            throw new error_1.InvalidDeliveryMethodError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
        }
        if (handler.includeFields) {
          params.includeFields = JSON.stringify(handler.includeFields);
        }
        if (handler.metafieldNamespaces) {
          params.metafieldNamespaces = JSON.stringify(handler.metafieldNamespaces);
        }
        if (handler.subTopic) {
          const subTopicString = `subTopic: "${handler.subTopic}",`;
          mutationArguments.MUTATION_PARAMS = subTopicString;
        }
        const paramsString = Object.entries(params).map(([key, value]) => `${key}: ${value}`).join(", ");
        mutationArguments.MUTATION_PARAMS += `webhookSubscription: {${paramsString}}`;
      }
      return (0, query_template_1.queryTemplate)(exports.TEMPLATE_MUTATION, mutationArguments);
    }
    function getMutationName(handler, operation) {
      switch (operation) {
        case types_2.WebhookOperation.Create:
          return `${getEndpoint(handler)}Create`;
        case types_2.WebhookOperation.Update:
          return `${getEndpoint(handler)}Update`;
        case types_2.WebhookOperation.Delete:
          return "webhookSubscriptionDelete";
        default:
          throw new error_1.ShopifyError(`Unrecognized operation '${operation}'`);
      }
    }
    function getEndpoint(handler) {
      switch (handler.deliveryMethod) {
        case types_2.DeliveryMethod.Http:
          return "webhookSubscription";
        case types_2.DeliveryMethod.EventBridge:
          return "eventBridgeWebhookSubscription";
        case types_2.DeliveryMethod.PubSub:
          return "pubSubWebhookSubscription";
        default:
          throw new error_1.ShopifyError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
      }
    }
    function isSuccess(result, handler, operation) {
      const mutationName = getMutationName(handler, operation);
      return Boolean(result.data && result.data[mutationName] && result.data[mutationName].userErrors.length === 0);
    }
    exports.TEMPLATE_GET_HANDLERS = `query shopifyApiReadWebhookSubscriptions {
  webhookSubscriptions(
    first: 250,
    after: {{END_CURSOR}},
  ) {
    edges {
      node {
        id
        topic
        includeFields
        metafieldNamespaces
        endpoint {
          __typename
          ... on WebhookHttpEndpoint {
            callbackUrl
          }
          ... on WebhookEventBridgeEndpoint {
            arn
          }
          ... on WebhookPubSubEndpoint {
            pubSubProject
            pubSubTopic
          }
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}`;
    exports.TEMPLATE_MUTATION = `
  mutation shopifyApiCreateWebhookSubscription {
    {{MUTATION_NAME}}(
      {{IDENTIFIER}},
      {{MUTATION_PARAMS}}
    ) {
      userErrors {
        field
        message
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/validate.js
var require_validate2 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateFactory = void 0;
    var logger_1 = require_logger();
    var hmac_validator_1 = require_hmac_validator();
    var types_1 = require_types4();
    var http_1 = require_http();
    var types_2 = require_types();
    var types_3 = require_types6();
    var registry_1 = require_registry();
    var OPTIONAL_HANDLER_PROPERTIES = {
      subTopic: types_2.ShopifyHeader.SubTopic
    };
    var HANDLER_PROPERTIES = {
      apiVersion: types_2.ShopifyHeader.ApiVersion,
      domain: types_2.ShopifyHeader.Domain,
      hmac: types_2.ShopifyHeader.Hmac,
      topic: types_2.ShopifyHeader.Topic,
      webhookId: types_2.ShopifyHeader.WebhookId,
      ...OPTIONAL_HANDLER_PROPERTIES
    };
    function validateFactory(config) {
      return async function validate({ rawBody, ...adapterArgs }) {
        const request = await (0, http_1.abstractConvertRequest)(adapterArgs);
        const validHmacResult = await (0, hmac_validator_1.validateHmacFromRequestFactory)(config)({
          type: types_1.HmacValidationType.Webhook,
          rawBody,
          ...adapterArgs
        });
        if (!validHmacResult.valid) {
          if (validHmacResult.reason === types_1.ValidationErrorReason.MissingHmac) {
            return {
              valid: false,
              reason: types_3.WebhookValidationErrorReason.MissingHeaders,
              missingHeaders: [types_2.ShopifyHeader.Hmac]
            };
          }
          if (validHmacResult.reason === types_1.ValidationErrorReason.InvalidHmac) {
            const log = (0, logger_1.logger)(config);
            await log.debug("Webhook HMAC validation failed. Please note that events manually triggered from a store's Notifications settings will fail this validation. To test this, please use the CLI or trigger the actual event in a development store.");
          }
          return validHmacResult;
        }
        return checkWebhookHeaders(request.headers);
      };
    }
    exports.validateFactory = validateFactory;
    function checkWebhookHeaders(headers) {
      const missingHeaders = [];
      const entries = Object.entries(HANDLER_PROPERTIES);
      const headerValues = entries.reduce((acc, [property, headerName]) => {
        const headerValue = (0, http_1.getHeader)(headers, headerName);
        if (headerValue) {
          acc[property] = headerValue;
        } else if (!(property in OPTIONAL_HANDLER_PROPERTIES)) {
          missingHeaders.push(headerName);
        }
        return acc;
      }, {});
      if (missingHeaders.length) {
        return {
          valid: false,
          reason: types_3.WebhookValidationErrorReason.MissingHeaders,
          missingHeaders
        };
      } else {
        return {
          valid: true,
          ...headerValues,
          ...headerValues.subTopic ? { subTopic: headerValues.subTopic } : {},
          topic: (0, registry_1.topicForStorage)(headerValues.topic)
        };
      }
    }
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/process.js
var require_process = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/process.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.process = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var network_1 = require_network();
    var http_1 = require_http();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var logger_1 = require_logger();
    var types_1 = require_types6();
    var validate_1 = require_validate2();
    var STATUS_TEXT_LOOKUP = {
      [network_1.StatusCode.Ok]: "OK",
      [network_1.StatusCode.BadRequest]: "Bad Request",
      [network_1.StatusCode.Unauthorized]: "Unauthorized",
      [network_1.StatusCode.NotFound]: "Not Found",
      [network_1.StatusCode.InternalServerError]: "Internal Server Error"
    };
    function process(config, webhookRegistry) {
      return async function process2({ context, rawBody, ...adapterArgs }) {
        const response = {
          statusCode: network_1.StatusCode.Ok,
          statusText: STATUS_TEXT_LOOKUP[network_1.StatusCode.Ok],
          headers: {}
        };
        await (0, logger_1.logger)(config).info("Receiving webhook request");
        const webhookCheck = await (0, validate_1.validateFactory)(config)({
          rawBody,
          ...adapterArgs
        });
        let errorMessage = "Unknown error while handling webhook";
        if (webhookCheck.valid) {
          const handlerResult = await callWebhookHandlers(config, webhookRegistry, webhookCheck, rawBody, context);
          response.statusCode = handlerResult.statusCode;
          if (!(0, http_1.isOK)(response)) {
            errorMessage = handlerResult.errorMessage || errorMessage;
          }
        } else {
          const errorResult = await handleInvalidWebhook(config, webhookCheck);
          response.statusCode = errorResult.statusCode;
          response.statusText = STATUS_TEXT_LOOKUP[response.statusCode];
          errorMessage = errorResult.errorMessage;
        }
        const returnResponse = await (0, http_1.abstractConvertResponse)(response, adapterArgs);
        if (!(0, http_1.isOK)(response)) {
          throw new ShopifyErrors.InvalidWebhookError({
            message: errorMessage,
            response: returnResponse
          });
        }
        return Promise.resolve(returnResponse);
      };
    }
    exports.process = process;
    async function callWebhookHandlers(config, webhookRegistry, webhookCheck, rawBody, context) {
      const log = (0, logger_1.logger)(config);
      const { hmac: _hmac, valid: _valid, ...loggingContext } = webhookCheck;
      await log.debug("Webhook request is valid, looking for HTTP handlers to call", loggingContext);
      const handlers = webhookRegistry[webhookCheck.topic] || [];
      const response = { statusCode: network_1.StatusCode.Ok };
      let found = false;
      for (const handler of handlers) {
        if (handler.deliveryMethod !== types_1.DeliveryMethod.Http) {
          continue;
        }
        if (!handler.callback) {
          response.statusCode = network_1.StatusCode.InternalServerError;
          response.errorMessage = "Cannot call webhooks.process with a webhook handler that doesn't have a callback";
          throw new ShopifyErrors.MissingWebhookCallbackError({
            message: response.errorMessage,
            response
          });
        }
        found = true;
        await log.debug("Found HTTP handler, triggering it", loggingContext);
        try {
          await handler.callback(webhookCheck.topic, webhookCheck.domain, rawBody, webhookCheck.webhookId, webhookCheck.apiVersion, ...(webhookCheck == null ? void 0 : webhookCheck.subTopic) ? webhookCheck.subTopic : "", context);
        } catch (error) {
          response.statusCode = network_1.StatusCode.InternalServerError;
          response.errorMessage = error.message;
        }
      }
      if (!found) {
        await log.debug("No HTTP handlers found", loggingContext);
        response.statusCode = network_1.StatusCode.NotFound;
        response.errorMessage = `No HTTP webhooks registered for topic ${webhookCheck.topic}`;
      }
      return response;
    }
    async function handleInvalidWebhook(config, webhookCheck) {
      const response = {
        statusCode: network_1.StatusCode.InternalServerError,
        errorMessage: "Unknown error while handling webhook"
      };
      switch (webhookCheck.reason) {
        case types_1.WebhookValidationErrorReason.MissingHeaders:
          response.statusCode = network_1.StatusCode.BadRequest;
          response.errorMessage = `Missing one or more of the required HTTP headers to process webhooks: [${webhookCheck.missingHeaders.join(", ")}]`;
          break;
        case types_1.WebhookValidationErrorReason.MissingBody:
          response.statusCode = network_1.StatusCode.BadRequest;
          response.errorMessage = "No body was received when processing webhook";
          break;
        case types_1.WebhookValidationErrorReason.InvalidHmac:
          response.statusCode = network_1.StatusCode.Unauthorized;
          response.errorMessage = `Could not validate request HMAC`;
          break;
      }
      await (0, logger_1.logger)(config).debug(`Webhook request is invalid, returning ${response.statusCode}: ${response.errorMessage}`);
      return response;
    }
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/index.js
var require_webhooks = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyWebhooks = void 0;
    var registry_1 = require_registry();
    var register_1 = require_register();
    var process_1 = require_process();
    var validate_1 = require_validate2();
    function shopifyWebhooks(config) {
      const webhookRegistry = (0, registry_1.registry)();
      return {
        addHandlers: (0, registry_1.addHandlers)(config, webhookRegistry),
        getTopicsAdded: (0, registry_1.getTopicsAdded)(webhookRegistry),
        getHandlers: (0, registry_1.getHandlers)(webhookRegistry),
        register: (0, register_1.register)(config, webhookRegistry),
        process: (0, process_1.process)(config, webhookRegistry),
        validate: (0, validate_1.validateFactory)(config)
      };
    }
    exports.shopifyWebhooks = shopifyWebhooks;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/check.js
var require_check = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.check = void 0;
    var admin_1 = require_admin();
    var error_1 = require_error();
    function check(config) {
      return async function check2({ session, plans, isTest = true, returnObject = false }) {
        if (!config.billing) {
          throw new error_1.BillingError({
            message: "Attempted to look for purchases without billing configs",
            errorData: []
          });
        }
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        const plansArray = Array.isArray(plans) ? plans : [plans];
        return assessPayments({
          plans: plansArray,
          client,
          isTest,
          returnObject
        });
      };
    }
    exports.check = check;
    async function assessPayments({ plans, client, isTest, returnObject }) {
      var _a;
      const returnValue = returnObject ? {
        hasActivePayment: false,
        oneTimePurchases: [],
        appSubscriptions: []
      } : false;
      let installation;
      let endCursor = null;
      do {
        const currentInstallations = await client.request(HAS_PAYMENTS_QUERY, { variables: { endCursor } });
        installation = (_a = currentInstallations.data) == null ? void 0 : _a.currentAppInstallation;
        if (returnObject) {
          installation.activeSubscriptions.map((subscription) => {
            if (subscriptionMeetsCriteria({ plans, isTest, subscription })) {
              returnValue.hasActivePayment = true;
              returnValue.appSubscriptions.push(subscription);
            }
          });
          installation.oneTimePurchases.edges.map((purchase) => {
            if (purchaseMeetsCriteria({ plans, isTest, purchase: purchase.node })) {
              returnValue.hasActivePayment = true;
              returnValue.oneTimePurchases.push(purchase.node);
            }
          });
        } else {
          const params = { plans, isTest, installation };
          if (hasSubscription(params) || hasOneTimePayment(params)) {
            return true;
          }
        }
        endCursor = installation.oneTimePurchases.pageInfo.endCursor;
      } while (installation == null ? void 0 : installation.oneTimePurchases.pageInfo.hasNextPage);
      return returnValue;
    }
    function subscriptionMeetsCriteria({ plans, isTest, subscription }) {
      return plans.includes(subscription.name) && (isTest || !subscription.test);
    }
    function purchaseMeetsCriteria({ plans, isTest, purchase }) {
      return plans.includes(purchase.name) && (isTest || !purchase.test) && purchase.status === "ACTIVE";
    }
    function hasSubscription({ plans, isTest, installation }) {
      return installation.activeSubscriptions.some((subscription) => subscriptionMeetsCriteria({ plans, isTest, subscription }));
    }
    function hasOneTimePayment({ plans, isTest, installation }) {
      return installation.oneTimePurchases.edges.some((purchase) => purchaseMeetsCriteria({ plans, isTest, purchase: purchase.node }));
    }
    var HAS_PAYMENTS_QUERY = `
  query appSubscription($endCursor: String) {
    currentAppInstallation {
      activeSubscriptions {
        id
        name
        test
        lineItems {
          id
          plan {
            pricingDetails {
              ... on AppRecurringPricing {
                price {
                  amount
                  currencyCode
                }
                interval
                discount {
                  durationLimitInIntervals
                  remainingDurationInIntervals
                  priceAfterDiscount {
                    amount
                  }
                  value {
                    ... on AppSubscriptionDiscountAmount {
                      amount {
                        amount
                        currencyCode
                      }
                    }
                    ... on AppSubscriptionDiscountPercentage {
                      percentage
                    }
                  }
                }
              }
              ... on AppUsagePricing {
                balanceUsed {
                  amount
                  currencyCode
                }
                cappedAmount {
                  amount
                  currencyCode
                }
                terms
              }
            }
          }
        }
      }
      oneTimePurchases(first: 250, sortKey: CREATED_AT, after: $endCursor) {
        edges {
          node {
            id
            name
            test
            status
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/request.js
var require_request = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.request = void 0;
    var types_1 = require_types();
    var error_1 = require_error();
    var get_embedded_app_url_1 = require_get_embedded_app_url();
    var admin_1 = require_admin();
    var crypto_1 = require_crypto();
    var types_2 = require_types2();
    function request(config) {
      return async function({ session, plan, isTest = true, returnUrl: returnUrlParam, returnObject = false, ...overrides }) {
        var _a;
        if (!config.billing || !config.billing[plan]) {
          throw new error_1.BillingError({
            message: `Could not find plan ${plan} in billing settings`,
            errorData: []
          });
        }
        const billingConfig = {
          ...config.billing[plan]
        };
        const filteredOverrides = Object.fromEntries(Object.entries(overrides).filter(([_key, value]) => value !== void 0));
        const cleanShopName = session.shop.replace(".myshopify.com", "");
        const embeddedAppUrl = (0, get_embedded_app_url_1.buildEmbeddedAppUrl)(config)((0, crypto_1.hashString)(`admin.shopify.com/store/${cleanShopName}`, types_2.HashFormat.Base64));
        const appUrl = `${config.hostScheme}://${config.hostName}?shop=${session.shop}`;
        const returnUrl = returnUrlParam || (config.isEmbeddedApp ? embeddedAppUrl : appUrl);
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        function isLineItemPlan(billingConfig2) {
          return "lineItems" in billingConfig2;
        }
        function isOneTimePlan(billingConfig2) {
          return billingConfig2.interval === types_1.BillingInterval.OneTime;
        }
        let data;
        if (isLineItemPlan(billingConfig)) {
          const mergedBillingConfigs = mergeBillingConfigs(billingConfig, filteredOverrides);
          const mutationRecurringResponse = await requestSubscriptionPayment({
            billingConfig: mergedBillingConfigs,
            plan,
            client,
            returnUrl,
            isTest
          });
          data = mutationRecurringResponse.appSubscriptionCreate;
        } else if (isOneTimePlan(billingConfig)) {
          const mutationOneTimeResponse = await requestSinglePayment({
            billingConfig: { ...billingConfig, ...filteredOverrides },
            plan,
            client,
            returnUrl,
            isTest
          });
          data = mutationOneTimeResponse.appPurchaseOneTimeCreate;
        } else {
          switch (billingConfig.interval) {
            case types_1.BillingInterval.Usage: {
              const mutationUsageResponse = await requestUsagePayment({
                billingConfig: { ...billingConfig, ...filteredOverrides },
                plan,
                client,
                returnUrl,
                isTest
              });
              data = mutationUsageResponse.appSubscriptionCreate;
              break;
            }
            default: {
              const mutationRecurringResponse = await requestRecurringPayment({
                billingConfig: { ...billingConfig, ...filteredOverrides },
                plan,
                client,
                returnUrl,
                isTest
              });
              data = mutationRecurringResponse.appSubscriptionCreate;
            }
          }
        }
        if ((_a = data.userErrors) == null ? void 0 : _a.length) {
          throw new error_1.BillingError({
            message: "Error while billing the store",
            errorData: data.userErrors
          });
        }
        if (returnObject) {
          return data;
        } else {
          return data.confirmationUrl;
        }
      };
    }
    exports.request = request;
    async function requestSubscriptionPayment({ billingConfig, plan, client, returnUrl, isTest }) {
      const lineItems = billingConfig.lineItems.map((item) => {
        if (item.interval === types_1.BillingInterval.Every30Days || item.interval === types_1.BillingInterval.Annual) {
          const appRecurringPricingDetails = {
            interval: item.interval,
            price: {
              amount: item.amount,
              currencyCode: item.currencyCode
            }
          };
          if (item.discount) {
            appRecurringPricingDetails.discount = {
              durationLimitInIntervals: item.discount.durationLimitInIntervals,
              value: {
                amount: item.discount.value.amount,
                percentage: item.discount.value.percentage
              }
            };
          }
          return {
            plan: {
              appRecurringPricingDetails
            }
          };
        } else if (item.interval === types_1.BillingInterval.Usage) {
          const appUsagePricingDetails = {
            terms: item.terms,
            cappedAmount: {
              amount: item.amount,
              currencyCode: item.currencyCode
            }
          };
          return {
            plan: {
              appUsagePricingDetails
            }
          };
        } else {
          throw new error_1.BillingError({
            message: "Invalid interval provided",
            errorData: [item]
          });
        }
      });
      const mutationResponse = await client.request(RECURRING_PURCHASE_MUTATION, {
        variables: {
          name: plan,
          trialDays: billingConfig.trialDays,
          replacementBehavior: billingConfig.replacementBehavior,
          returnUrl,
          test: isTest,
          lineItems
        }
      });
      if (mutationResponse.errors) {
        throw new error_1.BillingError({
          message: "Error while billing the store",
          errorData: mutationResponse.errors
        });
      }
      return mutationResponse.data;
    }
    async function requestRecurringPayment({ billingConfig, plan, client, returnUrl, isTest }) {
      var _a, _b, _c, _d, _e;
      const mutationResponse = await client.request(RECURRING_PURCHASE_MUTATION, {
        variables: {
          name: plan,
          trialDays: billingConfig.trialDays,
          replacementBehavior: billingConfig.replacementBehavior,
          returnUrl,
          test: isTest,
          lineItems: [
            {
              plan: {
                appRecurringPricingDetails: {
                  interval: billingConfig.interval,
                  price: {
                    amount: billingConfig.amount,
                    currencyCode: billingConfig.currencyCode
                  },
                  discount: {
                    durationLimitInIntervals: (_a = billingConfig.discount) == null ? void 0 : _a.durationLimitInIntervals,
                    value: {
                      amount: (_c = (_b = billingConfig.discount) == null ? void 0 : _b.value) == null ? void 0 : _c.amount,
                      percentage: (_e = (_d = billingConfig.discount) == null ? void 0 : _d.value) == null ? void 0 : _e.percentage
                    }
                  }
                }
              }
            }
          ]
        }
      });
      if (mutationResponse.errors) {
        throw new error_1.BillingError({
          message: "Error while billing the store",
          errorData: mutationResponse.errors
        });
      }
      return mutationResponse.data;
    }
    async function requestUsagePayment({ billingConfig, plan, client, returnUrl, isTest }) {
      const mutationResponse = await client.request(RECURRING_PURCHASE_MUTATION, {
        variables: {
          name: plan,
          returnUrl,
          test: isTest,
          trialDays: billingConfig.trialDays,
          replacementBehavior: billingConfig.replacementBehavior,
          lineItems: [
            {
              plan: {
                appUsagePricingDetails: {
                  terms: billingConfig.usageTerms,
                  cappedAmount: {
                    amount: billingConfig.amount,
                    currencyCode: billingConfig.currencyCode
                  }
                }
              }
            }
          ]
        }
      });
      if (mutationResponse.errors) {
        throw new error_1.BillingError({
          message: `Error while billing the store:: ${mutationResponse.errors}`,
          errorData: mutationResponse.errors
        });
      }
      return mutationResponse.data;
    }
    async function requestSinglePayment({ billingConfig, plan, client, returnUrl, isTest }) {
      const mutationResponse = await client.request(ONE_TIME_PURCHASE_MUTATION, {
        variables: {
          name: plan,
          returnUrl,
          test: isTest,
          price: {
            amount: billingConfig.amount,
            currencyCode: billingConfig.currencyCode
          }
        }
      });
      if (mutationResponse.errors) {
        throw new error_1.BillingError({
          message: "Error while billing the store",
          errorData: mutationResponse.errors
        });
      }
      return mutationResponse.data;
    }
    function mergeBillingConfigs(billingConfig, overrides) {
      const mergedConfig = { ...billingConfig, ...overrides };
      const mergedLineItems = [];
      if (billingConfig.lineItems && overrides.lineItems) {
        for (const i of billingConfig.lineItems) {
          let found = false;
          for (const j of overrides.lineItems) {
            if (i.interval === j.interval) {
              mergedLineItems.push({ ...i, ...j });
              found = true;
              break;
            }
          }
          if (!found) {
            mergedLineItems.push(i);
          }
        }
        mergedConfig.lineItems = mergedLineItems;
      }
      return mergedConfig;
    }
    var RECURRING_PURCHASE_MUTATION = `
  mutation test(
    $name: String!
    $lineItems: [AppSubscriptionLineItemInput!]!
    $returnUrl: URL!
    $test: Boolean
    $trialDays: Int
    $replacementBehavior: AppSubscriptionReplacementBehavior
  ) {
    appSubscriptionCreate(
      name: $name
      lineItems: $lineItems
      returnUrl: $returnUrl
      test: $test
      trialDays: $trialDays
      replacementBehavior: $replacementBehavior
    ) {
      appSubscription {
        id
        name
        test
      }
      confirmationUrl
      userErrors {
        field
        message
      }
    }
  }
`;
    var ONE_TIME_PURCHASE_MUTATION = `
  mutation test(
    $name: String!
    $price: MoneyInput!
    $returnUrl: URL!
    $test: Boolean
  ) {
    appPurchaseOneTimeCreate(
      name: $name
      price: $price
      returnUrl: $returnUrl
      test: $test
    ) {
      appPurchaseOneTime {
        id
        name
        test
      }
      confirmationUrl
      userErrors {
        field
        message
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/cancel.js
var require_cancel = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/cancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cancel = void 0;
    var admin_1 = require_admin();
    var error_1 = require_error();
    var CANCEL_MUTATION = `
  mutation appSubscriptionCancel($id: ID!, $prorate: Boolean) {
    appSubscriptionCancel(id: $id, prorate: $prorate) {
      appSubscription {
        id
        name
        test
      }
      userErrors {
        field
        message
      }
    }
  }
`;
    function cancel(config) {
      return async function(subscriptionInfo) {
        var _a, _b, _c, _d, _e, _f, _g;
        const { session, subscriptionId, prorate = true } = subscriptionInfo;
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        try {
          const response = await client.request(CANCEL_MUTATION, {
            variables: { id: subscriptionId, prorate }
          });
          if ((_b = (_a = response.data) == null ? void 0 : _a.appSubscriptionCancel) == null ? void 0 : _b.userErrors.length) {
            throw new error_1.BillingError({
              message: "Error while canceling a subscription",
              errorData: (_d = (_c = response.data) == null ? void 0 : _c.appSubscriptionCancel) == null ? void 0 : _d.userErrors
            });
          }
          return (_f = (_e = response.data) == null ? void 0 : _e.appSubscriptionCancel) == null ? void 0 : _f.appSubscription;
        } catch (error) {
          if (error instanceof error_1.GraphqlQueryError) {
            throw new error_1.BillingError({
              message: error.message,
              errorData: (_g = error.response) == null ? void 0 : _g.errors
            });
          } else {
            throw error;
          }
        }
      };
    }
    exports.cancel = cancel;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/subscriptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscriptions = void 0;
    var error_1 = require_error();
    var admin_1 = require_admin();
    var SUBSCRIPTION_QUERY = `
query appSubscription {
  currentAppInstallation {
    activeSubscriptions {
      id
      name
      test
      lineItems {
        id
        plan {
          pricingDetails {
            ... on AppRecurringPricing {
              price {
                amount
                currencyCode
              }
              interval
              discount {
                durationLimitInIntervals
                remainingDurationInIntervals
                priceAfterDiscount {
                  amount
                }
                value {
                  ... on AppSubscriptionDiscountAmount {
                    amount {
                      amount
                      currencyCode
                    }
                  }
                  ... on AppSubscriptionDiscountPercentage {
                    percentage
                  }
                }
              }
            }
            ... on AppUsagePricing {
              balanceUsed {
                amount
                currencyCode
              }
              cappedAmount {
                amount
                currencyCode
              }
              terms
            }
          }
        }
      }
    }
  }
}
`;
    function subscriptions(config) {
      return async function({ session }) {
        var _a;
        if (!config.billing) {
          throw new error_1.BillingError({
            message: "Attempted to look for purchases without billing configs",
            errorData: []
          });
        }
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        const response = await client.request(SUBSCRIPTION_QUERY);
        return (_a = response.data) == null ? void 0 : _a.currentAppInstallation;
      };
    }
    exports.subscriptions = subscriptions;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/index.js
var require_billing = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyBilling = void 0;
    var check_1 = require_check();
    var request_1 = require_request();
    var cancel_1 = require_cancel();
    var subscriptions_1 = require_subscriptions();
    function shopifyBilling(config) {
      return {
        check: (0, check_1.check)(config),
        request: (0, request_1.request)(config),
        cancel: (0, cancel_1.cancel)(config),
        subscriptions: (0, subscriptions_1.subscriptions)(config)
      };
    }
    exports.shopifyBilling = shopifyBilling;
  }
});

// node_modules/@shopify/shopify-api/lib/flow/validate.js
var require_validate3 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/flow/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateFactory = void 0;
    var types_1 = require_types4();
    var hmac_validator_1 = require_hmac_validator();
    function validateFactory(config) {
      return async function validate({ rawBody, ...adapterArgs }) {
        return (0, hmac_validator_1.validateHmacFromRequestFactory)(config)({
          type: types_1.HmacValidationType.Flow,
          rawBody,
          ...adapterArgs
        });
      };
    }
    exports.validateFactory = validateFactory;
  }
});

// node_modules/@shopify/shopify-api/lib/flow/index.js
var require_flow = __commonJS({
  "node_modules/@shopify/shopify-api/lib/flow/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyFlow = void 0;
    var validate_1 = require_validate3();
    function shopifyFlow(config) {
      return {
        validate: (0, validate_1.validateFactory)(config)
      };
    }
    exports.shopifyFlow = shopifyFlow;
  }
});

// node_modules/@shopify/shopify-api/lib/fulfillment-service/validate.js
var require_validate4 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/fulfillment-service/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateFactory = void 0;
    var hmac_validator_1 = require_hmac_validator();
    var types_1 = require_types4();
    function validateFactory(config) {
      return async function validate({ rawBody, ...adapterArgs }) {
        return (0, hmac_validator_1.validateHmacFromRequestFactory)(config)({
          type: types_1.HmacValidationType.FulfillmentService,
          rawBody,
          ...adapterArgs
        });
      };
    }
    exports.validateFactory = validateFactory;
  }
});

// node_modules/@shopify/shopify-api/lib/fulfillment-service/index.js
var require_fulfillment_service = __commonJS({
  "node_modules/@shopify/shopify-api/lib/fulfillment-service/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fulfillmentService = void 0;
    var validate_1 = require_validate4();
    function fulfillmentService(config) {
      return {
        validate: (0, validate_1.validateFactory)(config)
      };
    }
    exports.fulfillmentService = fulfillmentService;
  }
});

// node_modules/@shopify/shopify-api/lib/session/classes.js
var require_classes = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var session_1 = require_session();
    Object.defineProperty(exports, "Session", { enumerable: true, get: function() {
      return session_1.Session;
    } });
  }
});

// node_modules/@shopify/shopify-api/rest/types.js
var require_types7 = __commonJS({
  "node_modules/@shopify/shopify-api/rest/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/base-types.js
var require_base_types = __commonJS({
  "node_modules/@shopify/shopify-api/lib/base-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/auth/types.js
var require_types8 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestedTokenType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_types5(), exports);
    var token_exchange_1 = require_token_exchange();
    Object.defineProperty(exports, "RequestedTokenType", { enumerable: true, get: function() {
      return token_exchange_1.RequestedTokenType;
    } });
  }
});

// node_modules/@shopify/shopify-api/lib/billing/types.js
var require_types9 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/session/types.js
var require_types10 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/index.js
var require_lib = __commonJS({
  "node_modules/@shopify/shopify-api/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyApi = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var load_rest_resources_1 = require_load_rest_resources();
    var platform_1 = require_platform();
    var flags_1 = require_flags();
    var config_1 = require_config();
    var clients_1 = require_clients();
    var auth_1 = require_auth();
    var session_1 = require_session2();
    var utils_1 = require_utils();
    var webhooks_1 = require_webhooks();
    var billing_1 = require_billing();
    var logger_1 = require_logger();
    var version_1 = require_version();
    var client_1 = require_client2();
    var flow_1 = require_flow();
    var fulfillment_service_1 = require_fulfillment_service();
    tslib_1.__exportStar(require_error(), exports);
    tslib_1.__exportStar(require_classes(), exports);
    tslib_1.__exportStar(require_types7(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_base_types(), exports);
    tslib_1.__exportStar(require_types8(), exports);
    tslib_1.__exportStar(require_types9(), exports);
    tslib_1.__exportStar(require_types3(), exports);
    tslib_1.__exportStar(require_types10(), exports);
    tslib_1.__exportStar(require_types6(), exports);
    tslib_1.__exportStar(require_types4(), exports);
    function shopifyApi({ future, restResources, ...config }) {
      const libConfig = { ...config, future, restResources };
      const validatedConfig = (0, config_1.validateConfig)(libConfig);
      const shopify = {
        config: validatedConfig,
        clients: (0, clients_1.clientClasses)(validatedConfig),
        auth: (0, auth_1.shopifyAuth)(validatedConfig),
        session: (0, session_1.shopifySession)(validatedConfig),
        utils: (0, utils_1.shopifyUtils)(validatedConfig),
        webhooks: (0, webhooks_1.shopifyWebhooks)(validatedConfig),
        billing: (0, billing_1.shopifyBilling)(validatedConfig),
        flow: (0, flow_1.shopifyFlow)(validatedConfig),
        fulfillmentService: (0, fulfillment_service_1.fulfillmentService)(validatedConfig),
        logger: (0, logger_1.logger)(validatedConfig),
        rest: {}
      };
      if (restResources) {
        shopify.rest = (0, load_rest_resources_1.loadRestResources)({
          resources: restResources,
          config: validatedConfig,
          RestClient: (0, client_1.restClientClass)({ config: validatedConfig })
        });
      }
      shopify.logger.info(`version ${version_1.SHOPIFY_API_LIBRARY_VERSION}, environment ${(0, platform_1.abstractRuntimeString)()}`).catch((err) => console.log(err));
      (0, flags_1.logDisabledFutureFlags)(validatedConfig, shopify.logger);
      return shopify;
    }
    exports.shopifyApi = shopifyApi;
  }
});

// node_modules/@shopify/shopify-app-session-storage-prisma/dist/esm/prisma.mjs
var import_shopify_api = __toESM(require_lib(), 1);
var import_client = __toESM(require_index_browser(), 1);
var UNIQUE_KEY_CONSTRAINT_ERROR_CODE = "P2002";
var PrismaSessionStorage = class {
  constructor(prisma, { tableName } = {}) {
    this.prisma = prisma;
    this.tableName = "session";
    if (tableName) {
      this.tableName = tableName;
    }
    if (this.getSessionTable() === void 0) {
      throw new Error(`PrismaClient does not have a ${this.tableName} table`);
    }
    this.ready = this.getSessionTable().count().catch((cause) => {
      throw new MissingSessionTableError(`Prisma ${this.tableName} table does not exist. This could happen for a few reasons, see https://github.com/Shopify/shopify-app-js/tree/main/packages/apps/session-storage/shopify-app-session-storage-prisma#troubleshooting for more information`, cause);
    });
  }
  async storeSession(session) {
    await this.ready;
    const data = this.sessionToRow(session);
    try {
      await this.getSessionTable().upsert({
        where: { id: session.id },
        update: data,
        create: data
      });
    } catch (error) {
      if (error instanceof import_client.Prisma.PrismaClientKnownRequestError && error.code === UNIQUE_KEY_CONSTRAINT_ERROR_CODE) {
        console.log("Caught PrismaClientKnownRequestError P2002 - Unique Key Key Constraint, retrying upsert.");
        await this.getSessionTable().upsert({
          where: { id: session.id },
          update: data,
          create: data
        });
        return true;
      }
      throw error;
    }
    return true;
  }
  async loadSession(id) {
    await this.ready;
    const row = await this.getSessionTable().findUnique({
      where: { id }
    });
    if (!row) {
      return void 0;
    }
    return this.rowToSession(row);
  }
  async deleteSession(id) {
    await this.ready;
    try {
      await this.getSessionTable().delete({ where: { id } });
    } catch {
      return true;
    }
    return true;
  }
  async deleteSessions(ids) {
    await this.ready;
    await this.getSessionTable().deleteMany({ where: { id: { in: ids } } });
    return true;
  }
  async findSessionsByShop(shop) {
    await this.ready;
    const sessions = await this.getSessionTable().findMany({
      where: { shop },
      take: 25,
      orderBy: [{ expires: "desc" }]
    });
    return sessions.map((session) => this.rowToSession(session));
  }
  sessionToRow(session) {
    var _a;
    const sessionParams = session.toObject();
    return {
      id: session.id,
      shop: session.shop,
      state: session.state,
      isOnline: session.isOnline,
      scope: session.scope || null,
      expires: session.expires || null,
      accessToken: session.accessToken || "",
      userId: ((_a = sessionParams.onlineAccessInfo) == null ? void 0 : _a.associated_user.id) || null
    };
  }
  rowToSession(row) {
    const sessionParams = {
      id: row.id,
      shop: row.shop,
      state: row.state,
      isOnline: row.isOnline
    };
    if (row.expires) {
      sessionParams.expires = row.expires.getTime();
    }
    if (row.scope) {
      sessionParams.scope = row.scope;
    }
    if (row.accessToken) {
      sessionParams.accessToken = row.accessToken;
    }
    if (row.userId) {
      sessionParams.onlineAccessInfo = String(row.userId);
    }
    return import_shopify_api.Session.fromPropertyArray(Object.entries(sessionParams));
  }
  getSessionTable() {
    return this.prisma[this.tableName];
  }
};
var MissingSessionTableError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
  }
};
export {
  MissingSessionTableError,
  PrismaSessionStorage
};
//# sourceMappingURL=@shopify_shopify-app-session-storage-prisma.js.map
